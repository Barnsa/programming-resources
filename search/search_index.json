{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction 1 to 6, download example-1.py from 1 to 6 Download this file # example-1.py # a simple variable followed by the equals sign, we can make it any type of variable but we will make it an integer variable = 10 # This is the same thing but with a more descriptive and longer variable name the_number_of_vowels_in_banana = 3 #blank line Flavour is python, exec example-1.py from the beginning to the end Download this file # example-1.py # a simple variable followed by the equals sign, we can make it any type of variable but we will make it an integer variable = 10 # This is the same thing but with a more descriptive and longer variable name the_number_of_vowels_in_banana = 3 #blank line print ( variable ) print ( the_number_of_vowels_in_banana ) Output 10 3 2 to 5 example-1.py from 2 to 5 # a simple variable followed by the equals sign, we can make it any type of variable but we will make it an integer variable = 10 # This is the same thing but with a more descriptive and longer variable name the_number_of_vowels_in_banana = 3 to 5 example-1.py from the beginning to 5 # example-1.py # a simple variable followed by the equals sign, we can make it any type of variable but we will make it an integer variable = 10 # This is the same thing but with a more descriptive and longer variable name the_number_of_vowels_in_banana = 3 2 to 5, bash example-1.py from 2 to 5 # a simple variable followed by the equals sign, we can make it any type of variable but we will make it an integer variable = 10 # This is the same thing but with a more descriptive and longer variable name the_number_of_vowels_in_banana = 3 Contents Version Control Git Creating a repository Staging, committing and pushing Variables and state Data Types Assignment Naming Conventions Test your Knowledge: Probabilities Statements and Expressions Evaluation Order of Precedence Literal Values Boolean Logic Inequalities Testing PyTest Unit Testing Regression Testing Integration Testing Test Your Knowledge: Bug Hunt (broken code they have to fix) Selection If Else Elif Iteration For Test Your Knowledge: Countdown While Test Your Knowledge: Fibonacci Break Continue Else Test Your Knowledge: They Came From Space (or other game) Functions Function Syntax Returning Values Parameters Yield Lambda functions Passing functions Documentation Docstrings PyDoc (probably) Representation of Data Bytes, Characters and Byte Strings Bases Binary Hex ASCII, Unicode, UTF-8 Base64 Algorithms What is an algorithm? Efficiency Test Your Knowledge: Recursive Fibonacci Searching Sorting Classes and Objects Object-Oriented Programming Classes Objects Object properties and functions Class properties and functions Interacting with the Network Requests Sockets Scapy Beautiful Soup Modules and Packages Abstract Data Structures Trees Graphs Sets Low-Level Programming Assembly Language Interrupts Memory Organisation and Architecture The Stack The Heap Now Try: Core Wars Functional programming ???","title":"home"},{"location":"#introduction","text":"1 to 6, download example-1.py from 1 to 6 Download this file # example-1.py # a simple variable followed by the equals sign, we can make it any type of variable but we will make it an integer variable = 10 # This is the same thing but with a more descriptive and longer variable name the_number_of_vowels_in_banana = 3 #blank line Flavour is python, exec example-1.py from the beginning to the end Download this file # example-1.py # a simple variable followed by the equals sign, we can make it any type of variable but we will make it an integer variable = 10 # This is the same thing but with a more descriptive and longer variable name the_number_of_vowels_in_banana = 3 #blank line print ( variable ) print ( the_number_of_vowels_in_banana ) Output 10 3 2 to 5 example-1.py from 2 to 5 # a simple variable followed by the equals sign, we can make it any type of variable but we will make it an integer variable = 10 # This is the same thing but with a more descriptive and longer variable name the_number_of_vowels_in_banana = 3 to 5 example-1.py from the beginning to 5 # example-1.py # a simple variable followed by the equals sign, we can make it any type of variable but we will make it an integer variable = 10 # This is the same thing but with a more descriptive and longer variable name the_number_of_vowels_in_banana = 3 2 to 5, bash example-1.py from 2 to 5 # a simple variable followed by the equals sign, we can make it any type of variable but we will make it an integer variable = 10 # This is the same thing but with a more descriptive and longer variable name the_number_of_vowels_in_banana = 3","title":"Introduction"},{"location":"#contents","text":"Version Control Git Creating a repository Staging, committing and pushing Variables and state Data Types Assignment Naming Conventions Test your Knowledge: Probabilities Statements and Expressions Evaluation Order of Precedence Literal Values Boolean Logic Inequalities Testing PyTest Unit Testing Regression Testing Integration Testing Test Your Knowledge: Bug Hunt (broken code they have to fix) Selection If Else Elif Iteration For Test Your Knowledge: Countdown While Test Your Knowledge: Fibonacci Break Continue Else Test Your Knowledge: They Came From Space (or other game) Functions Function Syntax Returning Values Parameters Yield Lambda functions Passing functions Documentation Docstrings PyDoc (probably) Representation of Data Bytes, Characters and Byte Strings Bases Binary Hex ASCII, Unicode, UTF-8 Base64 Algorithms What is an algorithm? Efficiency Test Your Knowledge: Recursive Fibonacci Searching Sorting Classes and Objects Object-Oriented Programming Classes Objects Object properties and functions Class properties and functions Interacting with the Network Requests Sockets Scapy Beautiful Soup Modules and Packages Abstract Data Structures Trees Graphs Sets Low-Level Programming Assembly Language Interrupts Memory Organisation and Architecture The Stack The Heap Now Try: Core Wars Functional programming ???","title":"Contents"},{"location":"conditionals/","text":"Conditional Statements In python many variables that you create, whether they be basic ones or composite variables, need to be compared or evaluated at some point. If you have a variable in your code that isn't, then you probably don't need that variable. Evaluation Order of Precedence Much like in math, python has an order to when an evaluation gets done. Here is a table: Operators Meaning () Parentheses ** Exponent +x, -x, ~x Unary plus, Unary minus, Bitwise NOT *, /, //, % Multiplication, Division, Floor division, Modulus +, - Addition, Subtraction <<, >> Bitwise shift operators & Bitwise AND ^ Bitwise XOR | Bitwise OR ==, !=, >, >=, <, <=, is, is not, in, not in Comparisons, Identity, Membership operators not Logical NOT and Logical AND or Logical OR The higher something is on the table the sooner it gets done. Things in parenthesis get done first, mostly so you can force the order of precedence. There are a few gottcha's in this list that tend to get every programmer at least once, but for you guys the biggest one will be that logical AND is performed before logical OR. Consider this code fragment: example-1.py from 1 to 10 # example-1.py first example # Precedence of or & and meal = \"Spaghetti Carbonara\" money = 0 if meal == \"Spaghetti Carbonara\" or meal == \"Lasagne\" and money >= 2 : print ( \"Dinner is served!!\" ) else : print ( \"Can't deliver dinner :( \" ) Output Dinner is served!! The code as you can see, doesn't respond the way we might like. We would want the code to work out if we can have dinner if we picked a valid dinner option and also had enough money, but as we don't have enough money why is it evaluating as True? It's because the AND evaluates first, evaluating to False, and then the OR evaluates. In the evaluation of True OR False, it always evaluates to True. We can fix this with tht following modification: example-1.py from 13 to 22 # example-1.py second example # Fixed the order of precedents meal = \"Spaghetti Carbonara\" money = 0 if ( meal == \"Spaghetti Carbonara\" or meal == \"Lasagne\" ) and money >= 2 : print ( \"Dinner is served!!\" ) else : print ( \"Can't deliver dinner :( \" ) Output Can't deliver dinner :( The other order of precedence that you have to watch out for is that some evaluations start from the right, and others start from the left. Consider this code: example-2.py from 1 to 18 # example-2.py # Showing order of precedence through examples # As all of these have the same precedence, # they get evaluated starting from left-right: print ( 3 // 2 * 3 ) print ( 3 * 2 // 3 ) print ( 3 * 2 % 6 ) print ( 2 % 6 * 3 ) print ( 6 + 3 - 7 ) print ( 6 - 7 + 3 ) # Right to left precedence happens with ** # Output: 512, since 2**(3**2) = 2**9 print ( 2 ** 3 ** 2 ) # If 2 needs to be the first exponent evaluated, we need to use () # Output: 64, since (2**3)**2 = 8**2 print (( 2 ** 3 ) ** 2 ) Output 3 2 0 6 2 2 512 64 Literal Values We've covered all of the basic types in python; the string, Boolean, integer, and floating point number. However, python also supports a lot of other literal values that aren't commonly used. Below is a more comprehensive list of literal values: literal type sample String literal \"hello\",'hey' int literal 5 Long int literal 879564L (Only in python 2.x) Floating point 3.1459 Complex Literals 12j Boolean Literals True, False Special Literals None Unicode Literals u\"Hello\" Byte Literals b\"Hello\" Hex Literals 0x +hexValue Octal Literals 0o +octValue List Literals [] , [1, 2, 4, 5] Tuple Literals () , (9, ) , (1, 2, \"happy\") Dictionary Literals {} , {'x':7} Set Literals {8, 9, 10} For those interested in coding literals and some of the abstract ideas surrounding literal testing, you can find more reading on python 3 conventions here (WARNING: very advanced stuff!!). Generally though, you will only use basic types unless you are purposely trying to obfuscate your code, or doing type conversion specifically. It's just a good idea to be familiar with the other literals so that you aren't confused if you encounter them in other peoples code. The long integer isn't in python 3.x anymore as all integers are now treated as if they are long integers in python, to learn more about how it gets converted and how python is interpreted you can find it in the documentation here . Boolean Logic All logic inside a computer boils down to True or False logic. True is either represented by its name or by the number 1, False is represented by its name or 0. All modern classical (Von Neumann architecture) computers are based off of Boolean logic and Boolean algebra, this means that all the components inside the machine have been developed to take 1's and 0's and represent them in every way we need to create. TODO Inequalities If The first control statement you need to learn in Python is the if statement. If statements are used in the construction of conditional execution to create decision making code. The 'if' part will execute if the statement evaluates as true. Consider this example: example-3.py from 1 to 30 # example-3.py # if statements and control statements # Remember an if statement only triggers if it evaluates to True variable_1 = 10 variable_2 = 5 variable_3 = \"trigonometry\" variable_4 = 5.5 variable_5 = False if variable_1 > variable_2 : print ( f \" { variable_1 } is greater than { variable_2 } \" ) if variable_1 < variable_2 : print ( f \" { variable_1 } is less than { variable_2 } \" ) if variable_1 == variable_2 : print ( f \"variable_1: { variable_1 } and variable_2: { variable_2 } are equal\" ) if type ( variable_3 ) == int : print ( f \"variable_3 is an integer not a string, see: { variable_3 } \" ) if type ( variable_4 ) == float : print ( f \"variable_4 is a float type with a value of { variable_4 } \" ) if variable_5 is True : print ( f \"variable_5 is { variable_5 } \" ) if variable_5 is not True : print ( f \"variable_5 is { variable_5 } \" ) Output 10 is greater than 5 variable_4 is a float type with a value of 5.5 variable_5 is False Looking through this code you can see that some of the statements aren't printed. For instance, variable_3 is not of a type integer, you can also see that there are some statements that are there to catch different values of variable_1 and variable_2, and a statement to catch if variable_5 is True or False. This way of writing code isn't very readable however, because there are no logical connections between one statement and the others. This is where the elif statement comes in. Elif We use the 'else if' or 'elif' statement to logically join statements together and run multiple checks on the same objects. If we take the code above and turn it into a more complex set of if statements then we get something a little clearer: example-4.py from 1 to 30 # example-4.py # elif statements and evaluations # Remember an if or elif statement only triggers if it evaluates to True variable_1 = 10 variable_2 = 5 variable_3 = \"trigonometry\" variable_4 = 5.5 variable_5 = False if variable_1 > variable_2 : print ( f \" { variable_1 } is greater than { variable_2 } \" ) elif variable_1 < variable_2 : print ( f \" { variable_1 } is less than { variable_2 } \" ) elif variable_1 == variable_2 : print ( f \"variable_1: { variable_1 } and variable_2: { variable_2 } are equal\" ) if type ( variable_3 ) == int : print ( f \"variable_3 is an integer not a string, see: { variable_3 } \" ) if type ( variable_4 ) == float : print ( f \"variable_4 is a float type with a value of { variable_4 } \" ) if variable_5 is True : print ( f \"variable_5 is { variable_5 } \" ) elif variable_5 is not True : print ( f \"variable_5 is { variable_5 } \" ) Output 10 is greater than 5 variable_4 is a float type with a value of 5.5 variable_5 is False As you can see the code is a little more logically grouped and it helps with processing cycles too. Once an if statement is executed, if it evaluates to true in the first part of the statement then it doesn't have to run any of the elif statements. As soon as one of the steps evaluates to true then the evaluation can exit there. In our previous example, each if statement has to be evaluated independently, increasing the amount of processing that needs to be done and making your code less readable. But what happens if you evaluate something and you don't trigger any condition, well there is the 'else' statement that handles that. Else The else statement is designed to run after everything in the if/elif statement evaluates to False. Consider it a piece of code that runs 'if all else fails'. Else statements can also be used in loops which you will see later. Let's take the code we had in example 3 and 4 and improve it further to incorporate else statements: example-5.py from 1 to 40 # example-5.py # else statements # Remember an if or elif statement only triggers if it evaluates to True, # if all of them evaluate to false then the else statement runs. variable_1 = 10 variable_2 = 5 variable_3 = \"trigonometry\" variable_4 = 5.5 variable_5 = False if variable_1 > variable_2 : print ( f \" { variable_1 } is greater than { variable_2 } \" ) elif variable_1 < variable_2 : print ( f \" { variable_1 } is less than { variable_2 } \" ) elif variable_1 == variable_2 : print ( f \"variable_1: { variable_1 } and variable_2: { variable_2 } are equal\" ) else : print ( f \"Something went very wrong!! Variable 1 or 2 are broken.\" ) if type ( variable_3 ) == int : print ( f \"variable_3 is an integer not a string, see: { variable_3 } \" ) else : print ( f \"variable_3 is not an integer, see: { variable_3 } \" ) if type ( variable_4 ) == float : print ( f \"variable_4 is a float type with a value of { variable_4 } \" ) else : print ( f \"variable_4 is the wrong type.\" ) if variable_5 is True : print ( f \"variable_5 is { variable_5 } \" ) elif variable_5 is not True : print ( f \"variable_5 is { variable_5 } \" ) else : print ( f \"variable_5 is not a Boolean for some reason.\" ) ## This file has some dependencies in the README.md file, check line 50. If you change this file you might have to change it there too. Output 10 is greater than 5 variable_3 is not an integer, see: trigonometry variable_4 is a float type with a value of 5.5 variable_5 is False","title":"Conditionals"},{"location":"conditionals/#conditional-statements","text":"In python many variables that you create, whether they be basic ones or composite variables, need to be compared or evaluated at some point. If you have a variable in your code that isn't, then you probably don't need that variable.","title":"Conditional Statements"},{"location":"conditionals/#evaluation","text":"","title":"Evaluation"},{"location":"conditionals/#order-of-precedence","text":"Much like in math, python has an order to when an evaluation gets done. Here is a table: Operators Meaning () Parentheses ** Exponent +x, -x, ~x Unary plus, Unary minus, Bitwise NOT *, /, //, % Multiplication, Division, Floor division, Modulus +, - Addition, Subtraction <<, >> Bitwise shift operators & Bitwise AND ^ Bitwise XOR | Bitwise OR ==, !=, >, >=, <, <=, is, is not, in, not in Comparisons, Identity, Membership operators not Logical NOT and Logical AND or Logical OR The higher something is on the table the sooner it gets done. Things in parenthesis get done first, mostly so you can force the order of precedence. There are a few gottcha's in this list that tend to get every programmer at least once, but for you guys the biggest one will be that logical AND is performed before logical OR. Consider this code fragment: example-1.py from 1 to 10 # example-1.py first example # Precedence of or & and meal = \"Spaghetti Carbonara\" money = 0 if meal == \"Spaghetti Carbonara\" or meal == \"Lasagne\" and money >= 2 : print ( \"Dinner is served!!\" ) else : print ( \"Can't deliver dinner :( \" ) Output Dinner is served!! The code as you can see, doesn't respond the way we might like. We would want the code to work out if we can have dinner if we picked a valid dinner option and also had enough money, but as we don't have enough money why is it evaluating as True? It's because the AND evaluates first, evaluating to False, and then the OR evaluates. In the evaluation of True OR False, it always evaluates to True. We can fix this with tht following modification: example-1.py from 13 to 22 # example-1.py second example # Fixed the order of precedents meal = \"Spaghetti Carbonara\" money = 0 if ( meal == \"Spaghetti Carbonara\" or meal == \"Lasagne\" ) and money >= 2 : print ( \"Dinner is served!!\" ) else : print ( \"Can't deliver dinner :( \" ) Output Can't deliver dinner :( The other order of precedence that you have to watch out for is that some evaluations start from the right, and others start from the left. Consider this code: example-2.py from 1 to 18 # example-2.py # Showing order of precedence through examples # As all of these have the same precedence, # they get evaluated starting from left-right: print ( 3 // 2 * 3 ) print ( 3 * 2 // 3 ) print ( 3 * 2 % 6 ) print ( 2 % 6 * 3 ) print ( 6 + 3 - 7 ) print ( 6 - 7 + 3 ) # Right to left precedence happens with ** # Output: 512, since 2**(3**2) = 2**9 print ( 2 ** 3 ** 2 ) # If 2 needs to be the first exponent evaluated, we need to use () # Output: 64, since (2**3)**2 = 8**2 print (( 2 ** 3 ) ** 2 ) Output 3 2 0 6 2 2 512 64","title":"Order of Precedence"},{"location":"conditionals/#literal-values","text":"We've covered all of the basic types in python; the string, Boolean, integer, and floating point number. However, python also supports a lot of other literal values that aren't commonly used. Below is a more comprehensive list of literal values: literal type sample String literal \"hello\",'hey' int literal 5 Long int literal 879564L (Only in python 2.x) Floating point 3.1459 Complex Literals 12j Boolean Literals True, False Special Literals None Unicode Literals u\"Hello\" Byte Literals b\"Hello\" Hex Literals 0x +hexValue Octal Literals 0o +octValue List Literals [] , [1, 2, 4, 5] Tuple Literals () , (9, ) , (1, 2, \"happy\") Dictionary Literals {} , {'x':7} Set Literals {8, 9, 10} For those interested in coding literals and some of the abstract ideas surrounding literal testing, you can find more reading on python 3 conventions here (WARNING: very advanced stuff!!). Generally though, you will only use basic types unless you are purposely trying to obfuscate your code, or doing type conversion specifically. It's just a good idea to be familiar with the other literals so that you aren't confused if you encounter them in other peoples code. The long integer isn't in python 3.x anymore as all integers are now treated as if they are long integers in python, to learn more about how it gets converted and how python is interpreted you can find it in the documentation here .","title":"Literal Values"},{"location":"conditionals/#boolean-logic","text":"All logic inside a computer boils down to True or False logic. True is either represented by its name or by the number 1, False is represented by its name or 0. All modern classical (Von Neumann architecture) computers are based off of Boolean logic and Boolean algebra, this means that all the components inside the machine have been developed to take 1's and 0's and represent them in every way we need to create.","title":"Boolean Logic"},{"location":"conditionals/#todo-inequalities","text":"","title":"TODO Inequalities"},{"location":"conditionals/#if","text":"The first control statement you need to learn in Python is the if statement. If statements are used in the construction of conditional execution to create decision making code. The 'if' part will execute if the statement evaluates as true. Consider this example: example-3.py from 1 to 30 # example-3.py # if statements and control statements # Remember an if statement only triggers if it evaluates to True variable_1 = 10 variable_2 = 5 variable_3 = \"trigonometry\" variable_4 = 5.5 variable_5 = False if variable_1 > variable_2 : print ( f \" { variable_1 } is greater than { variable_2 } \" ) if variable_1 < variable_2 : print ( f \" { variable_1 } is less than { variable_2 } \" ) if variable_1 == variable_2 : print ( f \"variable_1: { variable_1 } and variable_2: { variable_2 } are equal\" ) if type ( variable_3 ) == int : print ( f \"variable_3 is an integer not a string, see: { variable_3 } \" ) if type ( variable_4 ) == float : print ( f \"variable_4 is a float type with a value of { variable_4 } \" ) if variable_5 is True : print ( f \"variable_5 is { variable_5 } \" ) if variable_5 is not True : print ( f \"variable_5 is { variable_5 } \" ) Output 10 is greater than 5 variable_4 is a float type with a value of 5.5 variable_5 is False Looking through this code you can see that some of the statements aren't printed. For instance, variable_3 is not of a type integer, you can also see that there are some statements that are there to catch different values of variable_1 and variable_2, and a statement to catch if variable_5 is True or False. This way of writing code isn't very readable however, because there are no logical connections between one statement and the others. This is where the elif statement comes in.","title":"If"},{"location":"conditionals/#elif","text":"We use the 'else if' or 'elif' statement to logically join statements together and run multiple checks on the same objects. If we take the code above and turn it into a more complex set of if statements then we get something a little clearer: example-4.py from 1 to 30 # example-4.py # elif statements and evaluations # Remember an if or elif statement only triggers if it evaluates to True variable_1 = 10 variable_2 = 5 variable_3 = \"trigonometry\" variable_4 = 5.5 variable_5 = False if variable_1 > variable_2 : print ( f \" { variable_1 } is greater than { variable_2 } \" ) elif variable_1 < variable_2 : print ( f \" { variable_1 } is less than { variable_2 } \" ) elif variable_1 == variable_2 : print ( f \"variable_1: { variable_1 } and variable_2: { variable_2 } are equal\" ) if type ( variable_3 ) == int : print ( f \"variable_3 is an integer not a string, see: { variable_3 } \" ) if type ( variable_4 ) == float : print ( f \"variable_4 is a float type with a value of { variable_4 } \" ) if variable_5 is True : print ( f \"variable_5 is { variable_5 } \" ) elif variable_5 is not True : print ( f \"variable_5 is { variable_5 } \" ) Output 10 is greater than 5 variable_4 is a float type with a value of 5.5 variable_5 is False As you can see the code is a little more logically grouped and it helps with processing cycles too. Once an if statement is executed, if it evaluates to true in the first part of the statement then it doesn't have to run any of the elif statements. As soon as one of the steps evaluates to true then the evaluation can exit there. In our previous example, each if statement has to be evaluated independently, increasing the amount of processing that needs to be done and making your code less readable. But what happens if you evaluate something and you don't trigger any condition, well there is the 'else' statement that handles that.","title":"Elif"},{"location":"conditionals/#else","text":"The else statement is designed to run after everything in the if/elif statement evaluates to False. Consider it a piece of code that runs 'if all else fails'. Else statements can also be used in loops which you will see later. Let's take the code we had in example 3 and 4 and improve it further to incorporate else statements: example-5.py from 1 to 40 # example-5.py # else statements # Remember an if or elif statement only triggers if it evaluates to True, # if all of them evaluate to false then the else statement runs. variable_1 = 10 variable_2 = 5 variable_3 = \"trigonometry\" variable_4 = 5.5 variable_5 = False if variable_1 > variable_2 : print ( f \" { variable_1 } is greater than { variable_2 } \" ) elif variable_1 < variable_2 : print ( f \" { variable_1 } is less than { variable_2 } \" ) elif variable_1 == variable_2 : print ( f \"variable_1: { variable_1 } and variable_2: { variable_2 } are equal\" ) else : print ( f \"Something went very wrong!! Variable 1 or 2 are broken.\" ) if type ( variable_3 ) == int : print ( f \"variable_3 is an integer not a string, see: { variable_3 } \" ) else : print ( f \"variable_3 is not an integer, see: { variable_3 } \" ) if type ( variable_4 ) == float : print ( f \"variable_4 is a float type with a value of { variable_4 } \" ) else : print ( f \"variable_4 is the wrong type.\" ) if variable_5 is True : print ( f \"variable_5 is { variable_5 } \" ) elif variable_5 is not True : print ( f \"variable_5 is { variable_5 } \" ) else : print ( f \"variable_5 is not a Boolean for some reason.\" ) ## This file has some dependencies in the README.md file, check line 50. If you change this file you might have to change it there too. Output 10 is greater than 5 variable_3 is not an integer, see: trigonometry variable_4 is a float type with a value of 5.5 variable_5 is False","title":"Else"},{"location":"for-loops/","text":"For Loops Anytime you want to do anything more than once in a Python program, you should consider putting it inside a loop. There are two types of loops in python, a 'for' loop and a 'while' loop. Generally 'for' loops are used when you know the amount of times you want to repeat something. It doesn't have to be an exact integer value, it can also be anything easily calculable. 'While' loops are used when you aren't sure how many times you need to repeat something, this could be to repeat something until a condition is reached or until a user tells it to stop. In python, all control statements use indentation to define blocks of grouped code. For Loops (definite iteration) Iterating iterables For loops always start with the keyword 'for' and then an iterator followed by some condition. Here are a few examples: example-1.py from the beginning to the end # example-1.py # Iterating iterables, a simple 'for' loop illustrating strings as iterables in python 3 string = 'hello world!' for i in string : print ( i ) In this first case, we define a sting of text we poignantly called string. Then we create the 'for' loop by stating that for each index (i) inside the string, we want to print out the value of 'i'. It is common practice in coding to use 'i' as the variable that iterates through something in a loop or for an index location for something iterable. The output of this code is that each letter is looked at by the 'i' in the for loop and then printed out to a new line in the console. example-2.py from the beginning to the end # example-2.py # iterating iterables, a basic example of a counting loop in python 3 word = 'banana' count = 0 for letter in word : if letter is 'a' : count = count + 1 # count +=1 would also work here print ( count ) Output 3 In this example, we have a more pythonic idea. The word 'letter' works the same way as the 'i' in the previous example, it's just more descriptive which helps with clarity when rereading later. See if you can work out what this program does without running it. Other than strings you can also iterate through any type of iterable including: dictionaries, lists, tuples and sets. Here are some examples: example-3.py from 3 to 6 # example-3.py first example list_of_fruit = [ 'apple' , 'banana' , 'cherry' ] for item in list_of_fruit : print ( item ) Output apple banana cherry example-3.py from 8 to 11 # example-3.py second example dictionary = { 'apple' : 3 , 'banana' : 5 , 'cherry' : 20 } for entry in dictionary . values (): # you can also use .items() or .keys() to get the dictionary pairs or keys print ( entry ) Output 3 5 20 example-3.py from 13 to the end # example-3.py third example dictionary = { 'apple' : 3 , 'banana' : 5 , 'cherry' : 20 } for entry in dictionary . items (): # See!! print ( entry ) for entry in dictionary . keys (): print ( entry ) Output ('apple', 3) ('banana', 5) ('cherry', 20) apple banana cherry Iterating Ranges Using the range function, we can also create 'for' loops that iterate a number of times. Consider these examples: example-4.py from 3 to 5 # example-4.py first example for count in range ( 10 ): # range(<stop>) print ( count ) Output 0 1 2 3 4 5 6 7 8 9 example-4.py from 7 to 9 # example-4.py second example for count in range ( 4 , 10 ): # range(<start>, <stop>) print ( count ) example-4.py from 11 to 13 # example-4.py third example for count in range ( 1 , 10 , 3 ): # range(<start>, <stop>, <increment>) print ( count ) In these examples, you can see how the range function is used to set a maximum limit to the number of times the 'for' loop iterates. Notice also that if you run the first example, count never makes it to 10, the numbers 0 all the way up to 9 are printed instead. example-4.py from 15 to 20 # example-4.py fourth example string = 'How long is a piece of string?' count = 0 for i in range ( len ( string )): count += 1 print ( count ) example-4.py from 22 to 24 # example-4.py fifth example for i in range ( sum ( range ( 4 , 10 ))): print ( 10 * i ) In these two examples, it's slightly more complicated to work out the integer after the calculation, but we know it will be a finite number. See if you can work out what these programs will print out without running them. Nested Loops All loops can also be nested inside each other consider this example: example-5.py from 1 to 8 # example-5.py first example # Nested Loops, some examples of nested for loops print ( \"First Example\" ) adjective = [ \"red\" , \"big\" , \"tasty\" ] fruits = [ \"apple\" , \"banana\" , \"cherry\" ] for x in adjective : for y in fruits : print ( x , y ) In this example we iterate over two separate lists and join them together in the print statement. In the outside 'for' loop, x runs through each of the items in the variable 'adjective', then the inner 'for' loop is called and y iterates through the 'fruits' variable. When the outer loop gets to the first index, it runs the inner loop until it completes all it's iterations and then x moves onto the next index. In our example this means that 'x' first has the value 'red', then 'y' iterates through each of the 'fruits' list printing out 'red apple', 'red banana' and 'red cherry' first... Run the code for yourself and see. To see how many times an inner loop will run, you can multiply it by all the possible different options of the outer loops and the inner loop to find out. Consider this example: example-5.py from 11 to the end # example-5.py second example number = [ \"3\" , \"2\" , \"1\" , \"100\" ] adjective = [ \"red\" , \"big\" , \"tasty\" ] fruits = [ \"apple\" , \"banana\" , \"cherry\" ] count = 0 for x in number : for y in adjective : for z in fruits : count += 1 print ( x , y , z ) total = len ( number ) * len ( adjective ) * len ( fruits ) # Multiplied as explained in the README.md if count == total : print ( \"We just proved how to calculate the number of times a loop runs!!\" ) print ( count ) else : print ( \"Epic fail dood!!\" ) If you run this code, you can see that the code runs 36 times and that that's exactly the same number of times as each of list lengths multiplied together. There are some other niche cases you may see in loops, one of which is the 'else' statement. example-6.py from 1 to 19 # example-6.py first example # Showing complex nested loops with else statements number = [ \"3\" , \"2\" , \"1\" , \"100\" ] adjective = [ \"red\" , \"big\" , \"tasty\" ] fruits = [ \"apple\" , \"banana\" , \"cherry\" ] count = 0 for x in number : for y in adjective : for z in fruits : count += 1 print ( x , y , z ) else : print ( \"inside loop!\" ) else : print ( \"inner loop\" ) else : print ( \"outside loop!\" ) print ( count ) print ( len ( number ) * len ( adjective ) * len ( fruits )) When the loop finishes, anything in the 'else' statement is executed. If the loop is broken out of or fails to execute, the 'else' statement doesn't execute. Try this for yourself: example-6.py from 22 to 39 # example-6.py second example # Showing broken complex nested loops with else statements number = [ \"3\" , \"2\" , \"1\" , \"100\" ] adjective = [ \"red\" , \"big\" , \"tasty\" ] fruits = [ \"apple\" , \"banana\" , \"cherry\" ] count = 0 for x in number : for y in adjective : for z in fruits : break else : print ( \"inside loop!\" ) else : print ( \"inner loop\" ) else : print ( \"outside loop!\" ) print ( count ) print ( len ( number ) * len ( adjective ) * len ( fruits )) Test Your Knowledge: Countdown See if you can create a loop that can count down from 10, and that once it gets to zero it prints the the word 'Liftoff!'. See if you can also make it print that the rocket was successfully launched.","title":"For Loops"},{"location":"for-loops/#for-loops","text":"Anytime you want to do anything more than once in a Python program, you should consider putting it inside a loop. There are two types of loops in python, a 'for' loop and a 'while' loop. Generally 'for' loops are used when you know the amount of times you want to repeat something. It doesn't have to be an exact integer value, it can also be anything easily calculable. 'While' loops are used when you aren't sure how many times you need to repeat something, this could be to repeat something until a condition is reached or until a user tells it to stop. In python, all control statements use indentation to define blocks of grouped code.","title":"For Loops"},{"location":"for-loops/#for-loops-definite-iteration","text":"","title":"For Loops (definite iteration)"},{"location":"for-loops/#iterating-iterables","text":"For loops always start with the keyword 'for' and then an iterator followed by some condition. Here are a few examples: example-1.py from the beginning to the end # example-1.py # Iterating iterables, a simple 'for' loop illustrating strings as iterables in python 3 string = 'hello world!' for i in string : print ( i ) In this first case, we define a sting of text we poignantly called string. Then we create the 'for' loop by stating that for each index (i) inside the string, we want to print out the value of 'i'. It is common practice in coding to use 'i' as the variable that iterates through something in a loop or for an index location for something iterable. The output of this code is that each letter is looked at by the 'i' in the for loop and then printed out to a new line in the console. example-2.py from the beginning to the end # example-2.py # iterating iterables, a basic example of a counting loop in python 3 word = 'banana' count = 0 for letter in word : if letter is 'a' : count = count + 1 # count +=1 would also work here print ( count ) Output 3 In this example, we have a more pythonic idea. The word 'letter' works the same way as the 'i' in the previous example, it's just more descriptive which helps with clarity when rereading later. See if you can work out what this program does without running it. Other than strings you can also iterate through any type of iterable including: dictionaries, lists, tuples and sets. Here are some examples: example-3.py from 3 to 6 # example-3.py first example list_of_fruit = [ 'apple' , 'banana' , 'cherry' ] for item in list_of_fruit : print ( item ) Output apple banana cherry example-3.py from 8 to 11 # example-3.py second example dictionary = { 'apple' : 3 , 'banana' : 5 , 'cherry' : 20 } for entry in dictionary . values (): # you can also use .items() or .keys() to get the dictionary pairs or keys print ( entry ) Output 3 5 20 example-3.py from 13 to the end # example-3.py third example dictionary = { 'apple' : 3 , 'banana' : 5 , 'cherry' : 20 } for entry in dictionary . items (): # See!! print ( entry ) for entry in dictionary . keys (): print ( entry ) Output ('apple', 3) ('banana', 5) ('cherry', 20) apple banana cherry","title":"Iterating iterables"},{"location":"for-loops/#iterating-ranges","text":"Using the range function, we can also create 'for' loops that iterate a number of times. Consider these examples: example-4.py from 3 to 5 # example-4.py first example for count in range ( 10 ): # range(<stop>) print ( count ) Output 0 1 2 3 4 5 6 7 8 9 example-4.py from 7 to 9 # example-4.py second example for count in range ( 4 , 10 ): # range(<start>, <stop>) print ( count ) example-4.py from 11 to 13 # example-4.py third example for count in range ( 1 , 10 , 3 ): # range(<start>, <stop>, <increment>) print ( count ) In these examples, you can see how the range function is used to set a maximum limit to the number of times the 'for' loop iterates. Notice also that if you run the first example, count never makes it to 10, the numbers 0 all the way up to 9 are printed instead. example-4.py from 15 to 20 # example-4.py fourth example string = 'How long is a piece of string?' count = 0 for i in range ( len ( string )): count += 1 print ( count ) example-4.py from 22 to 24 # example-4.py fifth example for i in range ( sum ( range ( 4 , 10 ))): print ( 10 * i ) In these two examples, it's slightly more complicated to work out the integer after the calculation, but we know it will be a finite number. See if you can work out what these programs will print out without running them.","title":"Iterating Ranges"},{"location":"for-loops/#nested-loops","text":"All loops can also be nested inside each other consider this example: example-5.py from 1 to 8 # example-5.py first example # Nested Loops, some examples of nested for loops print ( \"First Example\" ) adjective = [ \"red\" , \"big\" , \"tasty\" ] fruits = [ \"apple\" , \"banana\" , \"cherry\" ] for x in adjective : for y in fruits : print ( x , y ) In this example we iterate over two separate lists and join them together in the print statement. In the outside 'for' loop, x runs through each of the items in the variable 'adjective', then the inner 'for' loop is called and y iterates through the 'fruits' variable. When the outer loop gets to the first index, it runs the inner loop until it completes all it's iterations and then x moves onto the next index. In our example this means that 'x' first has the value 'red', then 'y' iterates through each of the 'fruits' list printing out 'red apple', 'red banana' and 'red cherry' first... Run the code for yourself and see. To see how many times an inner loop will run, you can multiply it by all the possible different options of the outer loops and the inner loop to find out. Consider this example: example-5.py from 11 to the end # example-5.py second example number = [ \"3\" , \"2\" , \"1\" , \"100\" ] adjective = [ \"red\" , \"big\" , \"tasty\" ] fruits = [ \"apple\" , \"banana\" , \"cherry\" ] count = 0 for x in number : for y in adjective : for z in fruits : count += 1 print ( x , y , z ) total = len ( number ) * len ( adjective ) * len ( fruits ) # Multiplied as explained in the README.md if count == total : print ( \"We just proved how to calculate the number of times a loop runs!!\" ) print ( count ) else : print ( \"Epic fail dood!!\" ) If you run this code, you can see that the code runs 36 times and that that's exactly the same number of times as each of list lengths multiplied together. There are some other niche cases you may see in loops, one of which is the 'else' statement. example-6.py from 1 to 19 # example-6.py first example # Showing complex nested loops with else statements number = [ \"3\" , \"2\" , \"1\" , \"100\" ] adjective = [ \"red\" , \"big\" , \"tasty\" ] fruits = [ \"apple\" , \"banana\" , \"cherry\" ] count = 0 for x in number : for y in adjective : for z in fruits : count += 1 print ( x , y , z ) else : print ( \"inside loop!\" ) else : print ( \"inner loop\" ) else : print ( \"outside loop!\" ) print ( count ) print ( len ( number ) * len ( adjective ) * len ( fruits )) When the loop finishes, anything in the 'else' statement is executed. If the loop is broken out of or fails to execute, the 'else' statement doesn't execute. Try this for yourself: example-6.py from 22 to 39 # example-6.py second example # Showing broken complex nested loops with else statements number = [ \"3\" , \"2\" , \"1\" , \"100\" ] adjective = [ \"red\" , \"big\" , \"tasty\" ] fruits = [ \"apple\" , \"banana\" , \"cherry\" ] count = 0 for x in number : for y in adjective : for z in fruits : break else : print ( \"inside loop!\" ) else : print ( \"inner loop\" ) else : print ( \"outside loop!\" ) print ( count ) print ( len ( number ) * len ( adjective ) * len ( fruits ))","title":"Nested Loops"},{"location":"for-loops/#test-your-knowledge-countdown","text":"See if you can create a loop that can count down from 10, and that once it gets to zero it prints the the word 'Liftoff!'. See if you can also make it print that the rocket was successfully launched.","title":"Test Your Knowledge: Countdown"},{"location":"functions/","text":"Functions Functions are self contained objects that are","title":"Functions"},{"location":"functions/#functions","text":"Functions are self contained objects that are","title":"Functions"},{"location":"recursion/","text":"Recursion","title":"Recursion"},{"location":"recursion/#recursion","text":"","title":"Recursion"},{"location":"statements-and-expressions/","text":"","title":"Index"},{"location":"values-and-types/","text":"Values and Types There are 4 basic types in python; Boolean, integer, floating point number and string. Booleans or \"bools\" are either true or false, a one or a zero, they are representative of the binary calculations that make computers work. Integers are any whole number and can be both positive and negative numbers, where as floating point numbers are anything with a decimal point in. A string is an interesting type as it also works like an iterable which we'll see more of later, but it stores a string of characters together. Every time we make a value that a computer needs to be able to reuse, we call that type a \"variable\". Let's look at some examples of how we use types and make variables: Basic Types: Creating your first variable To create your first variable it's pretty easy, you just name it and then use the assignment operator to assign it to that name. This will create a sort of pet name, pseudonym, or alias for a location in memory where the object that contains the value is then stored. Anytime you use that pseudonym it'll refer to whatever is stored in that object again. It's easier to show you then it is to explain it, so make sure you feel comfortable with everything here before you move on. Naming Conventions Variable names can start with a number, letter, or underscore, but not any other special character. PEP8 Python programming conventions say that variables should be named with all lower case letters, for longer variable names each word should be separated by underscores: example-1.py from the beginning to the end # example-1.py # a simple variable followed by the equals sign, we can make it any type of variable but we will make it an integer variable = 10 # This is the same thing but with a more descriptive and longer variable name the_number_of_vowels_in_banana = 3 #blank line print ( variable ) print ( the_number_of_vowels_in_banana ) As code is read many more times than its written, so generally speaking, longer variable names help others understand your code better. It's also good practice when you start to be very descriptive, so when you look back over your code to prompt you and study your programming, you'll remember what it was you were doing and how it works at a glance. Assignment Python is a dynamically typed language, what this means is that you don't have to know what type of data you want to label with a variable name to be able to create it. In statically typed languages such as the 'C' family of languages, you must declare the type of data you are going to store in memory before you store it. In python, variables dynamically change behind the scenes to accommodate different basic types, here's an example: example-2.py from the beginning to the end # example-2.py variable = 10 print ( variable ) variable = True print ( variable ) variable = \"hello\" print ( variable ) variable = 3.14 print ( variable ) In this example, our variable ambiguously called \"variable\" is a single location in memory. Each time we use the assignment operator (the equals sign), we force the variable to reference a different type of data and then ask it to print out to the screen. We're printing out the contents of the same alias every time, we're just overwriting the data in that location. We can also check the types of data with the next example: example-3.py from the beginning to the end # example-3.py variable = 10 print ( variable ) print ( type ( variable )) variable = True print ( variable ) print ( type ( variable )) variable = \"hello\" print ( variable ) print ( type ( variable )) variable = 3.14 print ( variable ) print ( type ( variable )) Output 10 <class 'int'> True <class 'bool'> hello <class 'str'> 3.14 <class 'float'> This does exactly the same as example 2 but it also prints out the basic type or object of the variable at each stage. Now you can see each of the types printed out too... see for yourself! Test Your Knowledge: Making your own variables For this knowledge test, using appropriate naming conventions try making your own variables to describe numbers and strings you might use in your own programs. Make variables to contain a happy birthday wish, the value of pi to 5 decimal places, your favourite integer under 100, a variable containing the meaning of life, and the true or false logic of whether a mouse is larger than a Giraffe. Try to make at least one variable of every basic type. Composite Types Lists There are also types that store or arrange basic types to make it easier to work with them, the three composite types are; lists, dictionaries, and tuples. Lists store a malleable group of variables that are easy to work with because the values can be referred to by index. An index is the numerical location of the position that a variable is in a list. Consider this list: example-4.py from 1 to 4 # example-4.py name_of_a_list = [ \"variables\" , \"are\" , \"contained\" , \"in\" , \"here\" , 12 , True , 33.33334 ] print ( name_of_a_list [ 3 ]) As all indexes start at the number zero as a general rule in programming, we could also represent this data in a table like this: index number 0 1 2 3 4 5 6 7 variable data \"variables\" \"are\" \"contained\" \"in\" \"here\" 12 True 33.33334 We can write code to interact with an index value like this: example-4.py from 1 to 5 # example-4.py name_of_a_list = [ \"variables\" , \"are\" , \"contained\" , \"in\" , \"here\" , 12 , True , 33.33334 ] print ( name_of_a_list [ 3 ]) Which one of the variables do you think gets printed?? If you guessed \"contained\" then you just got caught out by the one thing that catches out every programmer at least once. As we said, all indexes start at the number 0 as a general rule. So \"variables\" is at index 0, \"are\" at index 1, and so on. The astute among you may have noticed that the only difference between interacting with a list and making a list is the use of the assignment operator. That's true of all variables, assigning requires the assignment operator and using the data doesn't. Tuples are similar to lists in that they have an index number for the location of the data, but they are not mutable, which is to say they cannot change their data once they are created. Tuples Tuples can be treated in two ways, as a record and as an immutable list. As a record, tuples are used to store data in a certain order and keep it that way, generally for use later in the code: example-5.py from 1 to 10 # example-5.py first example # showing that tuples are immutable by breaking things # odds of being struck by lightning tuple_as_a_record = ( \"lightning strike\" , ( 1 , 700000 )) accident , ( number_of_people , in_population ) = tuple_as_a_record # tuple unpacking print ( f \"\"\"The chance of being the victim of a { accident } , is { number_of_people } in { in_population } \"\"\" ) In this example, the data is stored in a tuple and then unpacked for use in the print statement. You could print a packed tuple but you would get a print out with brackets too. Unpacking a tuple creates new objects that are referenced by the variables used in the unpacking, if you change the value of those variables then you'll only change the value of the new objects and not the values in the tuple you just unpacked. This is a good way to have records hard coded into a program Here is a short example of how that works: example-5.py from 12 to the end # example-5.py second example # showing that tuples are immutable by breaking things tuple_as_a_record = ( \"meteor shower\" , ( 1 , 20000 )) accident , ( number_of_people , in_population ) = tuple_as_a_record # tuple unpacking accident = \"shark attack\" print ( accident ) print ( tuple_as_a_record ) This brings us nicely onto the other way to use tuples, as immutable lists. The reason you use tuples as immutable lists is so that you can use slicing and other list functionality that also works with tuples, but without the fear of someone else in your production team modifying the list by accident. Another way to store data as records is to store it as a dictionary. Dictionary Dictionaries are an interesting data structure, its used to store data in key value pairs so that you can easily access the data by label instead of by index value. This is especially helpful if you want to dynamically create a csv file or know you need to store categorised data throughout a program, but other people are in charge of much of the data input. Dictionaries always have this form: d = { < key > : < value > , < key > : < value > , . . . < key > : < value > } Multiple values can be stored under the same key, and even any other objects, and all of them can be referenced with the key. Consider this assignment: example-6.py from 1 to 21 # example-6.py first example # how to create a dictionary and how to fill it our_dict = { \"Boston\" : \"Bruins\" , \"Buffalo\" : \"Sabres\" , \"Detroit\" : \"Redwings\" , \"Florida\" : \"Panthers\" , \"Montreal\" : \"Canadiens\" , \"Ottawa\" : \"Senators\" , \"Tampa\" : \"Lightning\" , \"Toronto\" : \"Maple Leafs\" } print ( type ( our_dict )) our_dict [ \"New Jersey\" ] = \"Devils\" print ( our_dict ) print ( our_dict . items ()) ## prints out all the pairs of <keys>:<values> print ( our_dict . keys ()) ## prints out all the <keys> print ( our_dict . values ()) ## prints out all the <values> Output <class 'dict'> {'Boston': 'Bruins', 'Buffalo': 'Sabres', 'Detroit': 'Redwings', 'Florida': 'Panthers', 'Montreal': 'Canadiens', 'Ottawa': 'Senators', 'Tampa': 'Lightning', 'Toronto': 'Maple Leafs', 'New Jersey': 'Devils'} dict_items([('Boston', 'Bruins'), ('Buffalo', 'Sabres'), ('Detroit', 'Redwings'), ('Florida', 'Panthers'), ('Montreal', 'Canadiens'), ('Ottawa', 'Senators'), ('Tampa', 'Lightning'), ('Toronto', 'Maple Leafs'), ('New Jersey', 'Devils')]) dict_keys(['Boston', 'Buffalo', 'Detroit', 'Florida', 'Montreal', 'Ottawa', 'Tampa', 'Toronto', 'New Jersey']) dict_values(['Bruins', 'Sabres', 'Redwings', 'Panthers', 'Canadiens', 'Senators', 'Lightning', 'Maple Leafs', 'Devils']) In this example we can see that it is reasonably simple to create a dictionary, you can either create an empty one or in our example have it pre-filled with a few things to get the ball rolling. Then as you progress in the program you can also add to it like any other dynamic object, this is done in our code with the line: example-6.py from 15 to 15 our_dict [ \"New Jersey\" ] = \"Devils\" The first part is the name of our dictionary, then the key we want to use inside the square brackets, and then the assignment operator followed by the value we want to give it.Using all of these basic and composite types are what make up everything you'll do to store, label, and create data inside a python program. Test Your Knowledge: Make for yourself a list, a tuple and a dictionary. Then look at different ways to add, remove, delete and generally manipulate the data that is associated with these composite types. The file \"test-your-knowledge.py\" has some broken code for you to fix and some notes on interesting ways to manipulate data in these composite types for you to complete. test-your-knowledge.py from 1 to 3 # test-your-knowledge.py # Broken code to illustrate composite type manipulation in python 3.5 # . . . ## First create an empty dictionary called \"dictionary_of_things\",","title":"Values and Types"},{"location":"values-and-types/#values-and-types","text":"There are 4 basic types in python; Boolean, integer, floating point number and string. Booleans or \"bools\" are either true or false, a one or a zero, they are representative of the binary calculations that make computers work. Integers are any whole number and can be both positive and negative numbers, where as floating point numbers are anything with a decimal point in. A string is an interesting type as it also works like an iterable which we'll see more of later, but it stores a string of characters together. Every time we make a value that a computer needs to be able to reuse, we call that type a \"variable\". Let's look at some examples of how we use types and make variables:","title":"Values and Types"},{"location":"values-and-types/#basic-types-creating-your-first-variable","text":"To create your first variable it's pretty easy, you just name it and then use the assignment operator to assign it to that name. This will create a sort of pet name, pseudonym, or alias for a location in memory where the object that contains the value is then stored. Anytime you use that pseudonym it'll refer to whatever is stored in that object again. It's easier to show you then it is to explain it, so make sure you feel comfortable with everything here before you move on.","title":"Basic Types: Creating your first variable"},{"location":"values-and-types/#naming-conventions","text":"Variable names can start with a number, letter, or underscore, but not any other special character. PEP8 Python programming conventions say that variables should be named with all lower case letters, for longer variable names each word should be separated by underscores: example-1.py from the beginning to the end # example-1.py # a simple variable followed by the equals sign, we can make it any type of variable but we will make it an integer variable = 10 # This is the same thing but with a more descriptive and longer variable name the_number_of_vowels_in_banana = 3 #blank line print ( variable ) print ( the_number_of_vowels_in_banana ) As code is read many more times than its written, so generally speaking, longer variable names help others understand your code better. It's also good practice when you start to be very descriptive, so when you look back over your code to prompt you and study your programming, you'll remember what it was you were doing and how it works at a glance.","title":"Naming Conventions"},{"location":"values-and-types/#assignment","text":"Python is a dynamically typed language, what this means is that you don't have to know what type of data you want to label with a variable name to be able to create it. In statically typed languages such as the 'C' family of languages, you must declare the type of data you are going to store in memory before you store it. In python, variables dynamically change behind the scenes to accommodate different basic types, here's an example: example-2.py from the beginning to the end # example-2.py variable = 10 print ( variable ) variable = True print ( variable ) variable = \"hello\" print ( variable ) variable = 3.14 print ( variable ) In this example, our variable ambiguously called \"variable\" is a single location in memory. Each time we use the assignment operator (the equals sign), we force the variable to reference a different type of data and then ask it to print out to the screen. We're printing out the contents of the same alias every time, we're just overwriting the data in that location. We can also check the types of data with the next example: example-3.py from the beginning to the end # example-3.py variable = 10 print ( variable ) print ( type ( variable )) variable = True print ( variable ) print ( type ( variable )) variable = \"hello\" print ( variable ) print ( type ( variable )) variable = 3.14 print ( variable ) print ( type ( variable )) Output 10 <class 'int'> True <class 'bool'> hello <class 'str'> 3.14 <class 'float'> This does exactly the same as example 2 but it also prints out the basic type or object of the variable at each stage. Now you can see each of the types printed out too... see for yourself!","title":"Assignment"},{"location":"values-and-types/#test-your-knowledge-making-your-own-variables","text":"For this knowledge test, using appropriate naming conventions try making your own variables to describe numbers and strings you might use in your own programs. Make variables to contain a happy birthday wish, the value of pi to 5 decimal places, your favourite integer under 100, a variable containing the meaning of life, and the true or false logic of whether a mouse is larger than a Giraffe. Try to make at least one variable of every basic type.","title":"Test Your Knowledge: Making your own variables"},{"location":"values-and-types/#composite-types","text":"","title":"Composite Types"},{"location":"values-and-types/#lists","text":"There are also types that store or arrange basic types to make it easier to work with them, the three composite types are; lists, dictionaries, and tuples. Lists store a malleable group of variables that are easy to work with because the values can be referred to by index. An index is the numerical location of the position that a variable is in a list. Consider this list: example-4.py from 1 to 4 # example-4.py name_of_a_list = [ \"variables\" , \"are\" , \"contained\" , \"in\" , \"here\" , 12 , True , 33.33334 ] print ( name_of_a_list [ 3 ]) As all indexes start at the number zero as a general rule in programming, we could also represent this data in a table like this: index number 0 1 2 3 4 5 6 7 variable data \"variables\" \"are\" \"contained\" \"in\" \"here\" 12 True 33.33334 We can write code to interact with an index value like this: example-4.py from 1 to 5 # example-4.py name_of_a_list = [ \"variables\" , \"are\" , \"contained\" , \"in\" , \"here\" , 12 , True , 33.33334 ] print ( name_of_a_list [ 3 ]) Which one of the variables do you think gets printed?? If you guessed \"contained\" then you just got caught out by the one thing that catches out every programmer at least once. As we said, all indexes start at the number 0 as a general rule. So \"variables\" is at index 0, \"are\" at index 1, and so on. The astute among you may have noticed that the only difference between interacting with a list and making a list is the use of the assignment operator. That's true of all variables, assigning requires the assignment operator and using the data doesn't. Tuples are similar to lists in that they have an index number for the location of the data, but they are not mutable, which is to say they cannot change their data once they are created.","title":"Lists"},{"location":"values-and-types/#tuples","text":"Tuples can be treated in two ways, as a record and as an immutable list. As a record, tuples are used to store data in a certain order and keep it that way, generally for use later in the code: example-5.py from 1 to 10 # example-5.py first example # showing that tuples are immutable by breaking things # odds of being struck by lightning tuple_as_a_record = ( \"lightning strike\" , ( 1 , 700000 )) accident , ( number_of_people , in_population ) = tuple_as_a_record # tuple unpacking print ( f \"\"\"The chance of being the victim of a { accident } , is { number_of_people } in { in_population } \"\"\" ) In this example, the data is stored in a tuple and then unpacked for use in the print statement. You could print a packed tuple but you would get a print out with brackets too. Unpacking a tuple creates new objects that are referenced by the variables used in the unpacking, if you change the value of those variables then you'll only change the value of the new objects and not the values in the tuple you just unpacked. This is a good way to have records hard coded into a program Here is a short example of how that works: example-5.py from 12 to the end # example-5.py second example # showing that tuples are immutable by breaking things tuple_as_a_record = ( \"meteor shower\" , ( 1 , 20000 )) accident , ( number_of_people , in_population ) = tuple_as_a_record # tuple unpacking accident = \"shark attack\" print ( accident ) print ( tuple_as_a_record ) This brings us nicely onto the other way to use tuples, as immutable lists. The reason you use tuples as immutable lists is so that you can use slicing and other list functionality that also works with tuples, but without the fear of someone else in your production team modifying the list by accident. Another way to store data as records is to store it as a dictionary.","title":"Tuples"},{"location":"values-and-types/#dictionary","text":"Dictionaries are an interesting data structure, its used to store data in key value pairs so that you can easily access the data by label instead of by index value. This is especially helpful if you want to dynamically create a csv file or know you need to store categorised data throughout a program, but other people are in charge of much of the data input. Dictionaries always have this form: d = { < key > : < value > , < key > : < value > , . . . < key > : < value > } Multiple values can be stored under the same key, and even any other objects, and all of them can be referenced with the key. Consider this assignment: example-6.py from 1 to 21 # example-6.py first example # how to create a dictionary and how to fill it our_dict = { \"Boston\" : \"Bruins\" , \"Buffalo\" : \"Sabres\" , \"Detroit\" : \"Redwings\" , \"Florida\" : \"Panthers\" , \"Montreal\" : \"Canadiens\" , \"Ottawa\" : \"Senators\" , \"Tampa\" : \"Lightning\" , \"Toronto\" : \"Maple Leafs\" } print ( type ( our_dict )) our_dict [ \"New Jersey\" ] = \"Devils\" print ( our_dict ) print ( our_dict . items ()) ## prints out all the pairs of <keys>:<values> print ( our_dict . keys ()) ## prints out all the <keys> print ( our_dict . values ()) ## prints out all the <values> Output <class 'dict'> {'Boston': 'Bruins', 'Buffalo': 'Sabres', 'Detroit': 'Redwings', 'Florida': 'Panthers', 'Montreal': 'Canadiens', 'Ottawa': 'Senators', 'Tampa': 'Lightning', 'Toronto': 'Maple Leafs', 'New Jersey': 'Devils'} dict_items([('Boston', 'Bruins'), ('Buffalo', 'Sabres'), ('Detroit', 'Redwings'), ('Florida', 'Panthers'), ('Montreal', 'Canadiens'), ('Ottawa', 'Senators'), ('Tampa', 'Lightning'), ('Toronto', 'Maple Leafs'), ('New Jersey', 'Devils')]) dict_keys(['Boston', 'Buffalo', 'Detroit', 'Florida', 'Montreal', 'Ottawa', 'Tampa', 'Toronto', 'New Jersey']) dict_values(['Bruins', 'Sabres', 'Redwings', 'Panthers', 'Canadiens', 'Senators', 'Lightning', 'Maple Leafs', 'Devils']) In this example we can see that it is reasonably simple to create a dictionary, you can either create an empty one or in our example have it pre-filled with a few things to get the ball rolling. Then as you progress in the program you can also add to it like any other dynamic object, this is done in our code with the line: example-6.py from 15 to 15 our_dict [ \"New Jersey\" ] = \"Devils\" The first part is the name of our dictionary, then the key we want to use inside the square brackets, and then the assignment operator followed by the value we want to give it.Using all of these basic and composite types are what make up everything you'll do to store, label, and create data inside a python program.","title":"Dictionary"},{"location":"values-and-types/#test-your-knowledge","text":"Make for yourself a list, a tuple and a dictionary. Then look at different ways to add, remove, delete and generally manipulate the data that is associated with these composite types. The file \"test-your-knowledge.py\" has some broken code for you to fix and some notes on interesting ways to manipulate data in these composite types for you to complete. test-your-knowledge.py from 1 to 3 # test-your-knowledge.py # Broken code to illustrate composite type manipulation in python 3.5 # . . . ## First create an empty dictionary called \"dictionary_of_things\",","title":"Test Your Knowledge:"},{"location":"while-loops/","text":"Iteration or Loops Anytime you want to do anything more than once in a Python program, you should consider putting it inside a loop. There are two types of loops in python, a 'for' loop and a 'while' loop. Generally 'for' loops are used when you know the amount of times you want to repeat something. It doesn't have to be an exact integer value, it can also be anything easily calculable. 'While' loops are used when you aren't sure how many times you need to repeat something or you need to do something recursively. In python, all control statements use indentation to define blocks of grouped code. While Loops (indefinite iteration) In 'while' loops, there is a definite shape to the way every one of them is written. Every 'while' loop is this kind of shape: while < condition > : < statements > < additional statements > The condition is to indicate when the loop must stop, the statements must contain something you want to do repetitively, and the additional statements are things such as the 'else' statement that we saw in the 'for' loop examples too. Consider this simple while loop: example-1.py from the beginning to the end # example-1.py # Your very first while loop... count = 5 while count > 0 : print ( count ) count -= 1 if count == 2 : break else : print ( \"Loop finished.\" ) Can you figure out what it does?? In this example we have a variable called count that stores a value (5), this number has to be on the outside of the loop so that it can be properly modified, if it was inside the loop then it wouldn't change because each iteration of the loop would create it's own version of the variable due to the rules of scope. The check is run for the loop, which determines that the value of count is greater than zero, so runs the loop. We first print the value of count, we do this first because if we decrement count first then we would print out the value '4' not '5'. Next we decrement the count by 1, this statement is the same as count = count - 1 . The 'if' statement looks to see if the value of count is 2, and if it is to break out of the while loop. The 'else statement only activates when the while loop successfully runs and exits naturally, so it never runs here because the break statement gets tripped. Example 'while' loops Here are a few 'while' loops to give you some ideas of the kinds of ways you might use them: example-2.py from the beginning to the end # example-2.py # Search and index pet = [ \"dog\" , \"cat\" , \"rabbit\" , \"snake\" , \"octopus\" , ] search = \"buffalo\" i = 0 while i < len ( pet ): if pet [ i ] == search : # we would have found search in pet print ( f \"We found the search term in index { i } .\" ) break i += 1 else : # We didn't find the search item in the list print ( \"We didn't find the search term!\" )","title":"While Loops"},{"location":"while-loops/#iteration-or-loops","text":"Anytime you want to do anything more than once in a Python program, you should consider putting it inside a loop. There are two types of loops in python, a 'for' loop and a 'while' loop. Generally 'for' loops are used when you know the amount of times you want to repeat something. It doesn't have to be an exact integer value, it can also be anything easily calculable. 'While' loops are used when you aren't sure how many times you need to repeat something or you need to do something recursively. In python, all control statements use indentation to define blocks of grouped code.","title":"Iteration or Loops"},{"location":"while-loops/#while-loops-indefinite-iteration","text":"In 'while' loops, there is a definite shape to the way every one of them is written. Every 'while' loop is this kind of shape: while < condition > : < statements > < additional statements > The condition is to indicate when the loop must stop, the statements must contain something you want to do repetitively, and the additional statements are things such as the 'else' statement that we saw in the 'for' loop examples too. Consider this simple while loop: example-1.py from the beginning to the end # example-1.py # Your very first while loop... count = 5 while count > 0 : print ( count ) count -= 1 if count == 2 : break else : print ( \"Loop finished.\" ) Can you figure out what it does?? In this example we have a variable called count that stores a value (5), this number has to be on the outside of the loop so that it can be properly modified, if it was inside the loop then it wouldn't change because each iteration of the loop would create it's own version of the variable due to the rules of scope. The check is run for the loop, which determines that the value of count is greater than zero, so runs the loop. We first print the value of count, we do this first because if we decrement count first then we would print out the value '4' not '5'. Next we decrement the count by 1, this statement is the same as count = count - 1 . The 'if' statement looks to see if the value of count is 2, and if it is to break out of the while loop. The 'else statement only activates when the while loop successfully runs and exits naturally, so it never runs here because the break statement gets tripped.","title":"While Loops (indefinite iteration)"},{"location":"while-loops/#example-while-loops","text":"Here are a few 'while' loops to give you some ideas of the kinds of ways you might use them: example-2.py from the beginning to the end # example-2.py # Search and index pet = [ \"dog\" , \"cat\" , \"rabbit\" , \"snake\" , \"octopus\" , ] search = \"buffalo\" i = 0 while i < len ( pet ): if pet [ i ] == search : # we would have found search in pet print ( f \"We found the search term in index { i } .\" ) break i += 1 else : # We didn't find the search item in the list print ( \"We didn't find the search term!\" )","title":"Example 'while' loops"}]}