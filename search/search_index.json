{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Insert introduction, explaining the expectation, about the 'test your knowledge' tasks, etc. Contents Version Control Git Creating a repository Staging, committing and pushing Variables and state Data Types Assignment Naming Conventions Test your Knowledge: Probabilities Statements and Expressions Evaluation Order of Precedence Literal Values Boolean Logic Inequalities Testing PyTest Unit Testing Regression Testing Integration Testing Test Your Knowledge: Bug Hunt (broken code they have to fix) Selection If Else Elif Iteration For Test Your Knowledge: Countdown While Test Your Knowledge: Fibonacci Break Continue Test Your Knowledge: They Came From Space (or other game) Functions Function Syntax Returning Values Parameters Yield Lambda functions Passing functions Documentation Docstrings PyDoc (probably) Representation of Data Bytes, Characters and Byte Strings Bases Binary Hex ASCII, Unicode, UTF-8 Base64 Algorithms What is an algorithm? Efficiency Test Your Knowledge: Recursive Fibonacci Searching Sorting Classes and Objects Object-Oriented Programming Classes Objects Object properties and functions Class properties and functions Interacting with the Network Requests Sockets Scapy Beautiful Soup Modules and Packages Abstract Data Structures Trees Graphs Sets Low-Level Programming Assembly Language Interrupts Memory Organisation and Architecture The Stack The Heap Now Try: Core Wars Functional programming ???","title":"home"},{"location":"#introduction","text":"Insert introduction, explaining the expectation, about the 'test your knowledge' tasks, etc.","title":"Introduction"},{"location":"#contents","text":"Version Control Git Creating a repository Staging, committing and pushing Variables and state Data Types Assignment Naming Conventions Test your Knowledge: Probabilities Statements and Expressions Evaluation Order of Precedence Literal Values Boolean Logic Inequalities Testing PyTest Unit Testing Regression Testing Integration Testing Test Your Knowledge: Bug Hunt (broken code they have to fix) Selection If Else Elif Iteration For Test Your Knowledge: Countdown While Test Your Knowledge: Fibonacci Break Continue Test Your Knowledge: They Came From Space (or other game) Functions Function Syntax Returning Values Parameters Yield Lambda functions Passing functions Documentation Docstrings PyDoc (probably) Representation of Data Bytes, Characters and Byte Strings Bases Binary Hex ASCII, Unicode, UTF-8 Base64 Algorithms What is an algorithm? Efficiency Test Your Knowledge: Recursive Fibonacci Searching Sorting Classes and Objects Object-Oriented Programming Classes Objects Object properties and functions Class properties and functions Interacting with the Network Requests Sockets Scapy Beautiful Soup Modules and Packages Abstract Data Structures Trees Graphs Sets Low-Level Programming Assembly Language Interrupts Memory Organisation and Architecture The Stack The Heap Now Try: Core Wars Functional programming ???","title":"Contents"},{"location":"Iteration/intro-to-iteration/","text":"Iteration Actually write this Anytime you want to do anything more than once in a Python program, you should consider putting it inside a loop. There are two types of loops in python, a 'for' loop and a 'while' loop. Generally 'for' loops are used when you know the amount of times you want to repeat something. It doesn't have to be an exact integer value, it can also be anything easily calculable. 'While' loops are used when you aren't sure how many times you need to repeat something, this could be to repeat something until a condition is reached or until a user tells it to stop. For loops While loops Also, recursion Recursion","title":"Iteration"},{"location":"Iteration/intro-to-iteration/#iteration","text":"Actually write this Anytime you want to do anything more than once in a Python program, you should consider putting it inside a loop. There are two types of loops in python, a 'for' loop and a 'while' loop. Generally 'for' loops are used when you know the amount of times you want to repeat something. It doesn't have to be an exact integer value, it can also be anything easily calculable. 'While' loops are used when you aren't sure how many times you need to repeat something, this could be to repeat something until a condition is reached or until a user tells it to stop. For loops While loops Also, recursion Recursion","title":"Iteration"},{"location":"Iteration/control-statements/","text":"Control Statements When using any type of loop you may want to","title":"Control Statements"},{"location":"Iteration/control-statements/#control-statements","text":"When using any type of loop you may want to","title":"Control Statements"},{"location":"Iteration/for-loops/","text":"For Loops Write intro specifically to for-loops Iterating iterables For loops always start with the keyword 'for' and then an iterator followed by some condition. Here are a few examples: File not found: for-loops/example-1.py In this first case, we define a sting of text we poignantly called string. Then we create the 'for' loop by stating that for each index (i) inside the string, we want to print out the value of 'i'. It is common practice in coding to use 'i' as the variable that iterates through something in a loop or for an index location for something iterable. The output of this code is that each letter is looked at by the 'i' in the for loop and then printed out to a new line in the console. File not found: for-loops/example-2.py In this example, we have a more pythonic idea. The word 'letter' works the same way as the 'i' in the previous example, it's just more descriptive which helps with clarity when rereading later. See if you can work out what this program does without running it. Other than strings you can also iterate through any type of iterable including: dictionaries, lists, tuples and sets. Here are some examples: File not found: for-loops/example-3.py File not found: for-loops/example-3.py File not found: for-loops/example-3.py Iterating Ranges Using the range function, we can also create 'for' loops that iterate a number of times. Consider these examples: File not found: for-loops/example-4.py File not found: for-loops/example-4.py File not found: for-loops/example-4.py In these examples, you can see how the range function is used to set a maximum limit to the number of times the 'for' loop iterates. Notice also that if you run the first example, count never makes it to 10, the numbers 0 all the way up to 9 are printed instead. File not found: for-loops/example-4.py File not found: for-loops/example-4.py In these two examples, it's slightly more complicated to work out the integer after the calculation, but we know it will be a finite number. See if you can work out what these programs will print out without running them. Nested Loops All loops can also be nested inside each other consider this example: File not found: for-loops/example-5.py In this example we iterate over two separate lists and join them together in the print statement. In the outside 'for' loop, x runs through each of the items in the variable 'adjective', then the inner 'for' loop is called and y iterates through the 'fruits' variable. When the outer loop gets to the first index, it runs the inner loop until it completes all it's iterations and then x moves onto the next index. In our example this means that 'x' first has the value 'red', then 'y' iterates through each of the 'fruits' list printing out 'red apple', 'red banana' and 'red cherry' first... Run the code for yourself and see. To see how many times an inner loop will run, you can multiply it by all the possible different options of the outer loops and the inner loop to find out. Consider this example: File not found: for-loops/example-5.py If you run this code, you can see that the code runs 36 times and that that's exactly the same number of times as each of list lengths multiplied together. There are some other niche cases you may see in loops, one of which is the 'else' statement. File not found: for-loops/example-6.py When the loop finishes, anything in the 'else' statement is executed. If the loop is broken out of or fails to execute, the 'else' statement doesn't execute. Try this for yourself: File not found: for-loops/example-6.py Test Your Knowledge: Countdown See if you can create a loop that can count down from 10, and that once it gets to zero it prints the the word 'Liftoff!'. See if you can also make it print that the rocket was successfully launched.","title":"For Loops"},{"location":"Iteration/for-loops/#for-loops","text":"Write intro specifically to for-loops","title":"For Loops"},{"location":"Iteration/for-loops/#iterating-iterables","text":"For loops always start with the keyword 'for' and then an iterator followed by some condition. Here are a few examples: File not found: for-loops/example-1.py In this first case, we define a sting of text we poignantly called string. Then we create the 'for' loop by stating that for each index (i) inside the string, we want to print out the value of 'i'. It is common practice in coding to use 'i' as the variable that iterates through something in a loop or for an index location for something iterable. The output of this code is that each letter is looked at by the 'i' in the for loop and then printed out to a new line in the console. File not found: for-loops/example-2.py In this example, we have a more pythonic idea. The word 'letter' works the same way as the 'i' in the previous example, it's just more descriptive which helps with clarity when rereading later. See if you can work out what this program does without running it. Other than strings you can also iterate through any type of iterable including: dictionaries, lists, tuples and sets. Here are some examples: File not found: for-loops/example-3.py File not found: for-loops/example-3.py File not found: for-loops/example-3.py","title":"Iterating iterables"},{"location":"Iteration/for-loops/#iterating-ranges","text":"Using the range function, we can also create 'for' loops that iterate a number of times. Consider these examples: File not found: for-loops/example-4.py File not found: for-loops/example-4.py File not found: for-loops/example-4.py In these examples, you can see how the range function is used to set a maximum limit to the number of times the 'for' loop iterates. Notice also that if you run the first example, count never makes it to 10, the numbers 0 all the way up to 9 are printed instead. File not found: for-loops/example-4.py File not found: for-loops/example-4.py In these two examples, it's slightly more complicated to work out the integer after the calculation, but we know it will be a finite number. See if you can work out what these programs will print out without running them.","title":"Iterating Ranges"},{"location":"Iteration/for-loops/#nested-loops","text":"All loops can also be nested inside each other consider this example: File not found: for-loops/example-5.py In this example we iterate over two separate lists and join them together in the print statement. In the outside 'for' loop, x runs through each of the items in the variable 'adjective', then the inner 'for' loop is called and y iterates through the 'fruits' variable. When the outer loop gets to the first index, it runs the inner loop until it completes all it's iterations and then x moves onto the next index. In our example this means that 'x' first has the value 'red', then 'y' iterates through each of the 'fruits' list printing out 'red apple', 'red banana' and 'red cherry' first... Run the code for yourself and see. To see how many times an inner loop will run, you can multiply it by all the possible different options of the outer loops and the inner loop to find out. Consider this example: File not found: for-loops/example-5.py If you run this code, you can see that the code runs 36 times and that that's exactly the same number of times as each of list lengths multiplied together. There are some other niche cases you may see in loops, one of which is the 'else' statement. File not found: for-loops/example-6.py When the loop finishes, anything in the 'else' statement is executed. If the loop is broken out of or fails to execute, the 'else' statement doesn't execute. Try this for yourself: File not found: for-loops/example-6.py","title":"Nested Loops"},{"location":"Iteration/for-loops/#test-your-knowledge-countdown","text":"See if you can create a loop that can count down from 10, and that once it gets to zero it prints the the word 'Liftoff!'. See if you can also make it print that the rocket was successfully launched.","title":"Test Your Knowledge: Countdown"},{"location":"Iteration/recursion/","text":"Recursion","title":"Recursion"},{"location":"Iteration/recursion/#recursion","text":"","title":"Recursion"},{"location":"Iteration/while-loops/","text":"While Loops (indefinite iteration) Anytime you want to do anything more than once in a Python program, you should consider putting it inside a loop. There are two types of loops in python, a 'for' loop and a 'while' loop. Generally 'for' loops are used when you know the amount of times you want to repeat something. It doesn't have to be an exact integer value, it can also be anything easily calculable. 'While' loops are used when you aren't sure how many times you need to repeat something or you need to do something recursively. In python, all control statements use indentation to define blocks of grouped code. In 'while' loops, there is a definite shape to the way every one of them is written. Every 'while' loop is this kind of shape: while < condition > : < statements > < additional statements > The condition is to indicate when the loop must stop, the statements must contain something you want to do repetitively, and the additional statements are things such as the 'else' statement that we saw in the 'for' loop examples too. Consider this simple while loop: File not found: while-loops/example-1.py Can you figure out what it does?? In this example we have a variable called count that stores a value (5), this number has to be on the outside of the loop so that it can be properly modified, if it was inside the loop then it wouldn't change because each iteration of the loop would create it's own version of the variable due to the rules of scope. The check is run for the loop, which determines that the value of count is greater than zero, so runs the loop. We first print the value of count, we do this first because if we decrement count first then we would print out the value '4' not '5'. Next we decrement the count by 1, this statement is the same as count = count - 1 . The 'if' statement looks to see if the value of count is 2, and if it is to break out of the while loop. The 'else statement only activates when the while loop successfully runs and exits naturally, so it never runs here because the break statement gets tripped. Example 'while' loops Here are a few 'while' loops to give you some ideas of the kinds of ways you might use them: File not found: while-loops/example-2.py File not found: while-loops/example-3.py Test your knowledge Create a while loop that calculates the Fibonacci sequence","title":"While Loops (indefinite iteration)"},{"location":"Iteration/while-loops/#while-loops-indefinite-iteration","text":"Anytime you want to do anything more than once in a Python program, you should consider putting it inside a loop. There are two types of loops in python, a 'for' loop and a 'while' loop. Generally 'for' loops are used when you know the amount of times you want to repeat something. It doesn't have to be an exact integer value, it can also be anything easily calculable. 'While' loops are used when you aren't sure how many times you need to repeat something or you need to do something recursively. In python, all control statements use indentation to define blocks of grouped code. In 'while' loops, there is a definite shape to the way every one of them is written. Every 'while' loop is this kind of shape: while < condition > : < statements > < additional statements > The condition is to indicate when the loop must stop, the statements must contain something you want to do repetitively, and the additional statements are things such as the 'else' statement that we saw in the 'for' loop examples too. Consider this simple while loop: File not found: while-loops/example-1.py Can you figure out what it does?? In this example we have a variable called count that stores a value (5), this number has to be on the outside of the loop so that it can be properly modified, if it was inside the loop then it wouldn't change because each iteration of the loop would create it's own version of the variable due to the rules of scope. The check is run for the loop, which determines that the value of count is greater than zero, so runs the loop. We first print the value of count, we do this first because if we decrement count first then we would print out the value '4' not '5'. Next we decrement the count by 1, this statement is the same as count = count - 1 . The 'if' statement looks to see if the value of count is 2, and if it is to break out of the while loop. The 'else statement only activates when the while loop successfully runs and exits naturally, so it never runs here because the break statement gets tripped.","title":"While Loops (indefinite iteration)"},{"location":"Iteration/while-loops/#example-while-loops","text":"Here are a few 'while' loops to give you some ideas of the kinds of ways you might use them: File not found: while-loops/example-2.py File not found: while-loops/example-3.py","title":"Example 'while' loops"},{"location":"Iteration/while-loops/#test-your-knowledge","text":"Create a while loop that calculates the Fibonacci sequence","title":"Test your knowledge"},{"location":"conditionals/","text":"Conditional Statements In python many variables that you create, whether they be basic ones or composite variables, need to be compared or evaluated at some point. If you have a variable in your code that isn't, then you probably don't need that variable. Evaluation In a python program, each line of the program is evaluated from top to bottom and left to right, unless order of precedents is in effect, with few exceptions. Common evaluations are things such as addition and subtraction, consider this code: example-9.py from the beginning to the end # example-9.py # Common evaluations and their outcomes variable_1 = 4 variable_2 = 2 variable_3 = 3 variable_4 = 5 # Simple math functionality print ( variable_1 + variable_2 ) print ( variable_1 - variable_2 ) print ( variable_1 * variable_2 ) print ( variable_1 / variable_2 ) # / always becomes a floating number print ( variable_1 % variable_2 ) print ( variable_1 // variable_2 ) # Let's do some type checking to prove it print ( type ( variable_1 + variable_2 )) print ( type ( variable_1 - variable_2 )) print ( type ( variable_1 * variable_2 )) print ( type ( variable_1 / variable_2 )) print ( type ( variable_1 % variable_2 )) print ( type ( variable_1 // variable_2 )) # String concatination # this uses the + in an interesting way string_1 = \"hey\" string_2 = \"you\" print ( string_1 + \" \" + string_2 + \"!\" ) print ( type ( string_1 + \" \" + string_2 + \"!\" )) # interesting evaluations that still happen from left to right # mostly... print ( variable_1 + variable_2 * variable_3 + variable_4 ) print ( variable_4 + variable_1 * variable_2 - variable_3 ) Output 6 2 8 2.0 0 2 <class 'int'> <class 'int'> <class 'int'> <class 'float'> <class 'int'> <class 'int'> hey you! <class 'str'> 15 10 The last few examples show how even though the order of precedence makes sure that multiplication and division happens before the addition and subtraction, but then immediately once they have been taken care of the evaluation happens from left to right again. As you can also see, the program executes from the top line to the bottom line of code. This creates a logical layout that we will utilise later. Order of Precedence Much like in math, python has an order to when an evaluation gets done. Here is a table: Operators Meaning () Parentheses ** Exponent +x, -x, ~x Unary plus, Unary minus, Bitwise NOT *, /, //, % Multiplication, Division, Floor division, Modulus +, - Addition, Subtraction <<, >> Bitwise shift operators & Bitwise AND ^ Bitwise XOR | Bitwise OR ==, !=, >, >=, <, <=, is, is not, in, not in Comparisons, Identity, Membership operators not Logical NOT and Logical AND or Logical OR The higher something is on the table the sooner it gets done. Things in parenthesis get done first, mostly so you can force the order of precedence. There are a few gottcha's in this list that tend to get every programmer at least once, but for you guys the biggest one will be that logical AND is performed before logical OR. Consider this code fragment: example-1.py from 1 to 10 # example-1.py first example # Precedence of or & and meal = \"Spaghetti Carbonara\" money = 0 if meal == \"Spaghetti Carbonara\" or meal == \"Lasagne\" and money >= 2 : print ( \"Dinner is served!!\" ) else : print ( \"Can't deliver dinner :( \" ) Output Dinner is served!! The code as you can see, doesn't respond the way we might like. We would want the code to work out if we can have dinner firstly if we picked a valid dinner option and also had enough money, but as we don't have enough money why is it evaluating as True? It's because the AND evaluates first, evaluating to False, and then the OR evaluates. In the evaluation of True OR False, it always evaluates to True. We can fix this with the following modification: example-1.py from 13 to 22 # example-1.py second example # Fixed the order of precedents meal = \"Spaghetti Carbonara\" money = 0 if ( meal == \"Spaghetti Carbonara\" or meal == \"Lasagne\" ) and money >= 2 : print ( \"Dinner is served!!\" ) else : print ( \"Can't deliver dinner :( \" ) Output Can't deliver dinner :( The other order of precedence that you have to watch out for is that some evaluations start from the right, and others start from the left. Consider this code: example-2.py from 1 to 18 # example-2.py # Showing order of precedence through examples # As all of these have the same precedence, # they get evaluated starting from left-right: print ( 3 // 2 * 3 ) print ( 3 * 2 // 3 ) print ( 3 * 2 % 6 ) print ( 2 % 6 * 3 ) print ( 6 + 3 - 7 ) print ( 6 - 7 + 3 ) # Right to left precedence happens with ** # Output: 512, since 2**(3**2) = 2**9 print ( 2 ** 3 ** 2 ) # If 2 needs to be the first exponent evaluated, we need to use () # Output: 64, since (2**3)**2 = 8**2 print (( 2 ** 3 ) ** 2 ) Output 3 2 0 6 2 2 512 64 You can see that depending on the type of evaluation used it will depend on whether it is evaluated from left to right. When in doubt you should test your code thoroughly and use parenthesis. Literal Values We've covered all of the basic types in python; the string, Boolean, integer, and floating point number. However, python also supports a lot of other literal values that aren't commonly used. Below is a more comprehensive list of literal values: literal type sample String literal \"hello\",'hey' int literal 5 Long int literal 879564L (Only in python 2.x) Floating point 3.1459 Complex Literals 12j Boolean Literals True, False Special Literals None Unicode Literals u\"Hello\" Byte Literals b\"Hello\" Hex Literals 0x +hexValue Octal Literals 0o +octValue List Literals [] , [1, 2, 4, 5] Tuple Literals () , (9, ) , (1, 2, \"happy\") Dictionary Literals {} , {'x':7} Set Literals {8, 9, 10} For those interested in coding literals and some of the abstract ideas surrounding literal testing, you can find more reading on python 3 conventions here (WARNING: very advanced stuff!!). Here are some examples of the literals being used: example-6.py from 1 to the end # example-6.py # examples of exotic literals at work string_literals = \"string\" integer_literals = 12 octal_literals = 0o11 hexadecimal_literals = 0x123 set_literals = { 2 , 4 , 7 } complex_literals = 12 J unicode_literals = u \"string\" byte_code_literals = b \"string\" print ( string_literals , integer_literals , octal_literals , hexadecimal_literals , set_literals , complex_literals , unicode_literals , byte_code_literals ) Output string 12 9 291 {2, 4, 7} 12j string b'string' Generally though, you will only use basic types unless you are purposely trying to obfuscate your code, or doing type conversion specifically. It's just a good idea to be familiar with the other literals so that you aren't confused if you encounter them in other peoples code. The long integer isn't in python 3.x anymore as all integers are now treated as if they are long integers in python, to learn more about how it gets converted and how python is interpreted you can find it in the documentation here . Inequalities To talk about inequalities, we must first need to talk about what an equality is. In python, equality is the symbol == and will directly check if one object is equal to another object. This is not the same as the 'is' keyword. Consider this code: example-8.py from 1 to 15 # example-8.py first example # Showing the difference between the is keyword and the equality operator list_1 = [ 10 ] list_2 = list_1 list_3 = list ( list_1 ) # test all of the equalities print ( list_1 == list_2 ) print ( list_1 == list_3 ) print ( list_2 == list_3 ) # test all of the is comparisons print ( list_1 is list_2 ) print ( list_1 is list_3 ) print ( list_2 is list_3 ) Output True True True True False False Here you can see that the difference between the equality operator and the is statement quite apparent. The equality operator looks to see if the values inside the lists are the same, whereas the is operator looks to see if the labels point to the same object. Understanding this key difference will help you to write good evaluation statements that behave the way you intend them to. Inequalities cover the other types of comparisons you might want to accomplish, consider this table: Symbol Meaning == equal to != not equal to > greater than >= greater than or equal to < less than <= less than or equal to A comparison always evaluates from left to right in the sense that if you were to create a comparison such as: print ( variable_1 > variable_2 ) it would compare if variable_1 is greater than variable_2. This can be complicated by multiple evaluations however, consider this example: print ( variable_1 > variable_2 > variable_3 ) Python handles this type of evaluation by taking the first two and then the last two variables and evaluating them separately. This makes it equivalent to; print ( variable_1 > variable_2 and variable_2 > variable_3 ) Make sure you consider this behaviour when you write your own conditional statements. If The first control statement you need to learn in Python is the if statement. If statements are used in the construction of conditional execution to create decision making code. The 'if' part will execute if the statement evaluates as true. Consider this example: example-3.py from 1 to 30 # example-3.py # if statements and control statements # Remember an if statement only triggers if it evaluates to True variable_1 = 10 variable_2 = 5 variable_3 = \"trigonometry\" variable_4 = 5.5 variable_5 = False if variable_1 > variable_2 : print ( f \" { variable_1 } is greater than { variable_2 } \" ) if variable_1 < variable_2 : print ( f \" { variable_1 } is less than { variable_2 } \" ) if variable_1 == variable_2 : print ( f \"variable_1: { variable_1 } and variable_2: { variable_2 } are equal\" ) if type ( variable_3 ) == int : print ( f \"variable_3 is an integer not a string, see: { variable_3 } \" ) if type ( variable_4 ) == float : print ( f \"variable_4 is a float type with a value of { variable_4 } \" ) if variable_5 is True : print ( f \"variable_5 is { variable_5 } \" ) if variable_5 is not True : print ( f \"variable_5 is { variable_5 } \" ) Output 10 is greater than 5 variable_4 is a float type with a value of 5.5 variable_5 is False Looking through this code you can see that some of the statements aren't printed. For instance, variable_3 is not of a type integer, you can also see that there are some statements that are there to catch different values of variable_1 and variable_2, and a statement to catch if variable_5 is True or False. This way of writing code isn't very readable however, because there are no logical connections between one statement and the others. This is where the elif statement comes in. Elif We use the 'else if' or 'elif' statement to logically join statements together and run multiple checks on the same objects. If we take the code above and turn it into a more complex set of if statements then we get something a little clearer: example-4.py from 1 to 30 # example-4.py # elif statements and evaluations # Remember an if or elif statement only triggers if it evaluates to True variable_1 = 10 variable_2 = 5 variable_3 = \"trigonometry\" variable_4 = 5.5 variable_5 = False if variable_1 > variable_2 : print ( f \" { variable_1 } is greater than { variable_2 } \" ) elif variable_1 < variable_2 : print ( f \" { variable_1 } is less than { variable_2 } \" ) elif variable_1 == variable_2 : print ( f \"variable_1: { variable_1 } and variable_2: { variable_2 } are equal\" ) if type ( variable_3 ) == int : print ( f \"variable_3 is an integer not a string, see: { variable_3 } \" ) if type ( variable_4 ) == float : print ( f \"variable_4 is a float type with a value of { variable_4 } \" ) if variable_5 is True : print ( f \"variable_5 is { variable_5 } \" ) elif variable_5 is not True : print ( f \"variable_5 is { variable_5 } \" ) Output 10 is greater than 5 variable_4 is a float type with a value of 5.5 variable_5 is False As you can see the code is a little more logically grouped and it helps with processing cycles too. Once an if statement is executed, if it evaluates to true in the first part of the statement then it doesn't have to run any of the elif statements. As soon as one of the steps evaluates to true then the evaluation can exit there. In our previous example, each if statement has to be evaluated independently, increasing the amount of processing that needs to be done and making your code less readable. But what happens if you evaluate something and you don't trigger any condition, well there is the 'else' statement that handles that. Else The else statement is designed to run after everything in the if/elif statement evaluates to False. Consider it a piece of code that runs 'if all else fails'. Else statements can also be used in loops which you will see later. Let's take the code we had in example 3 and 4 and improve it further to incorporate else statements: example-5.py from 1 to 40 # example-5.py # else statements # Remember an if or elif statement only triggers if it evaluates to True, # if all of them evaluate to false then the else statement runs. variable_1 = 10 variable_2 = 5 variable_3 = \"trigonometry\" variable_4 = 5.5 variable_5 = False if variable_1 > variable_2 : print ( f \" { variable_1 } is greater than { variable_2 } \" ) elif variable_1 < variable_2 : print ( f \" { variable_1 } is less than { variable_2 } \" ) elif variable_1 == variable_2 : print ( f \"variable_1: { variable_1 } and variable_2: { variable_2 } are equal\" ) else : print ( f \"Something went very wrong!! Variable 1 or 2 are broken.\" ) if type ( variable_3 ) == int : print ( f \"variable_3 is an integer not a string, see: { variable_3 } \" ) else : print ( f \"variable_3 is not an integer, see: { variable_3 } \" ) if type ( variable_4 ) == float : print ( f \"variable_4 is a float type with a value of { variable_4 } \" ) else : print ( f \"variable_4 is the wrong type.\" ) if variable_5 is True : print ( f \"variable_5 is { variable_5 } \" ) elif variable_5 is not True : print ( f \"variable_5 is { variable_5 } \" ) else : print ( f \"variable_5 is not a Boolean for some reason.\" ) ## This file has some dependencies in the README.md file, check line 50. If you change this file you might have to change it there too. Output 10 is greater than 5 variable_3 is not an integer, see: trigonometry variable_4 is a float type with a value of 5.5 variable_5 is False Boolean Logic All logic inside a computer boils down to True or False logic. True is either represented by its name or by the number 1, False is represented by its name or 0. All modern classical (Von Neumann architecture) computers are based off of Boolean logic and Boolean algebra, this means that all the components inside the machine have been developed to take 1's and 0's and represent them in every way we need to create useful data with. For the purposes of programming however, you need to understand how truth tables refer to AND, OR, NAND (not AND) and NOR (not OR) logic. Here are the truth tables for each of the logical comparisons AND True False True True False False False False OR True False True True True False True False NAND True False True False True False True True NOR True False True False False False False True When considering your if statements, you need to consider how they will be evaluated. Consider this code fragment: example-5.py from 1 to 40 # example-5.py # else statements # Remember an if or elif statement only triggers if it evaluates to True, # if all of them evaluate to false then the else statement runs. variable_1 = 10 variable_2 = 5 variable_3 = \"trigonometry\" variable_4 = 5.5 variable_5 = False if variable_1 > variable_2 : print ( f \" { variable_1 } is greater than { variable_2 } \" ) elif variable_1 < variable_2 : print ( f \" { variable_1 } is less than { variable_2 } \" ) elif variable_1 == variable_2 : print ( f \"variable_1: { variable_1 } and variable_2: { variable_2 } are equal\" ) else : print ( f \"Something went very wrong!! Variable 1 or 2 are broken.\" ) if type ( variable_3 ) == int : print ( f \"variable_3 is an integer not a string, see: { variable_3 } \" ) else : print ( f \"variable_3 is not an integer, see: { variable_3 } \" ) if type ( variable_4 ) == float : print ( f \"variable_4 is a float type with a value of { variable_4 } \" ) else : print ( f \"variable_4 is the wrong type.\" ) if variable_5 is True : print ( f \"variable_5 is { variable_5 } \" ) elif variable_5 is not True : print ( f \"variable_5 is { variable_5 } \" ) else : print ( f \"variable_5 is not a Boolean for some reason.\" ) ## This file has some dependencies in the README.md file, check line 50. If you change this file you might have to change it there too. Output 10 is greater than 5 variable_3 is not an integer, see: trigonometry variable_4 is a float type with a value of 5.5 variable_5 is False","title":"Conditionals"},{"location":"conditionals/#conditional-statements","text":"In python many variables that you create, whether they be basic ones or composite variables, need to be compared or evaluated at some point. If you have a variable in your code that isn't, then you probably don't need that variable.","title":"Conditional Statements"},{"location":"conditionals/#evaluation","text":"In a python program, each line of the program is evaluated from top to bottom and left to right, unless order of precedents is in effect, with few exceptions. Common evaluations are things such as addition and subtraction, consider this code: example-9.py from the beginning to the end # example-9.py # Common evaluations and their outcomes variable_1 = 4 variable_2 = 2 variable_3 = 3 variable_4 = 5 # Simple math functionality print ( variable_1 + variable_2 ) print ( variable_1 - variable_2 ) print ( variable_1 * variable_2 ) print ( variable_1 / variable_2 ) # / always becomes a floating number print ( variable_1 % variable_2 ) print ( variable_1 // variable_2 ) # Let's do some type checking to prove it print ( type ( variable_1 + variable_2 )) print ( type ( variable_1 - variable_2 )) print ( type ( variable_1 * variable_2 )) print ( type ( variable_1 / variable_2 )) print ( type ( variable_1 % variable_2 )) print ( type ( variable_1 // variable_2 )) # String concatination # this uses the + in an interesting way string_1 = \"hey\" string_2 = \"you\" print ( string_1 + \" \" + string_2 + \"!\" ) print ( type ( string_1 + \" \" + string_2 + \"!\" )) # interesting evaluations that still happen from left to right # mostly... print ( variable_1 + variable_2 * variable_3 + variable_4 ) print ( variable_4 + variable_1 * variable_2 - variable_3 ) Output 6 2 8 2.0 0 2 <class 'int'> <class 'int'> <class 'int'> <class 'float'> <class 'int'> <class 'int'> hey you! <class 'str'> 15 10 The last few examples show how even though the order of precedence makes sure that multiplication and division happens before the addition and subtraction, but then immediately once they have been taken care of the evaluation happens from left to right again. As you can also see, the program executes from the top line to the bottom line of code. This creates a logical layout that we will utilise later.","title":"Evaluation"},{"location":"conditionals/#order-of-precedence","text":"Much like in math, python has an order to when an evaluation gets done. Here is a table: Operators Meaning () Parentheses ** Exponent +x, -x, ~x Unary plus, Unary minus, Bitwise NOT *, /, //, % Multiplication, Division, Floor division, Modulus +, - Addition, Subtraction <<, >> Bitwise shift operators & Bitwise AND ^ Bitwise XOR | Bitwise OR ==, !=, >, >=, <, <=, is, is not, in, not in Comparisons, Identity, Membership operators not Logical NOT and Logical AND or Logical OR The higher something is on the table the sooner it gets done. Things in parenthesis get done first, mostly so you can force the order of precedence. There are a few gottcha's in this list that tend to get every programmer at least once, but for you guys the biggest one will be that logical AND is performed before logical OR. Consider this code fragment: example-1.py from 1 to 10 # example-1.py first example # Precedence of or & and meal = \"Spaghetti Carbonara\" money = 0 if meal == \"Spaghetti Carbonara\" or meal == \"Lasagne\" and money >= 2 : print ( \"Dinner is served!!\" ) else : print ( \"Can't deliver dinner :( \" ) Output Dinner is served!! The code as you can see, doesn't respond the way we might like. We would want the code to work out if we can have dinner firstly if we picked a valid dinner option and also had enough money, but as we don't have enough money why is it evaluating as True? It's because the AND evaluates first, evaluating to False, and then the OR evaluates. In the evaluation of True OR False, it always evaluates to True. We can fix this with the following modification: example-1.py from 13 to 22 # example-1.py second example # Fixed the order of precedents meal = \"Spaghetti Carbonara\" money = 0 if ( meal == \"Spaghetti Carbonara\" or meal == \"Lasagne\" ) and money >= 2 : print ( \"Dinner is served!!\" ) else : print ( \"Can't deliver dinner :( \" ) Output Can't deliver dinner :( The other order of precedence that you have to watch out for is that some evaluations start from the right, and others start from the left. Consider this code: example-2.py from 1 to 18 # example-2.py # Showing order of precedence through examples # As all of these have the same precedence, # they get evaluated starting from left-right: print ( 3 // 2 * 3 ) print ( 3 * 2 // 3 ) print ( 3 * 2 % 6 ) print ( 2 % 6 * 3 ) print ( 6 + 3 - 7 ) print ( 6 - 7 + 3 ) # Right to left precedence happens with ** # Output: 512, since 2**(3**2) = 2**9 print ( 2 ** 3 ** 2 ) # If 2 needs to be the first exponent evaluated, we need to use () # Output: 64, since (2**3)**2 = 8**2 print (( 2 ** 3 ) ** 2 ) Output 3 2 0 6 2 2 512 64 You can see that depending on the type of evaluation used it will depend on whether it is evaluated from left to right. When in doubt you should test your code thoroughly and use parenthesis.","title":"Order of Precedence"},{"location":"conditionals/#literal-values","text":"We've covered all of the basic types in python; the string, Boolean, integer, and floating point number. However, python also supports a lot of other literal values that aren't commonly used. Below is a more comprehensive list of literal values: literal type sample String literal \"hello\",'hey' int literal 5 Long int literal 879564L (Only in python 2.x) Floating point 3.1459 Complex Literals 12j Boolean Literals True, False Special Literals None Unicode Literals u\"Hello\" Byte Literals b\"Hello\" Hex Literals 0x +hexValue Octal Literals 0o +octValue List Literals [] , [1, 2, 4, 5] Tuple Literals () , (9, ) , (1, 2, \"happy\") Dictionary Literals {} , {'x':7} Set Literals {8, 9, 10} For those interested in coding literals and some of the abstract ideas surrounding literal testing, you can find more reading on python 3 conventions here (WARNING: very advanced stuff!!). Here are some examples of the literals being used: example-6.py from 1 to the end # example-6.py # examples of exotic literals at work string_literals = \"string\" integer_literals = 12 octal_literals = 0o11 hexadecimal_literals = 0x123 set_literals = { 2 , 4 , 7 } complex_literals = 12 J unicode_literals = u \"string\" byte_code_literals = b \"string\" print ( string_literals , integer_literals , octal_literals , hexadecimal_literals , set_literals , complex_literals , unicode_literals , byte_code_literals ) Output string 12 9 291 {2, 4, 7} 12j string b'string' Generally though, you will only use basic types unless you are purposely trying to obfuscate your code, or doing type conversion specifically. It's just a good idea to be familiar with the other literals so that you aren't confused if you encounter them in other peoples code. The long integer isn't in python 3.x anymore as all integers are now treated as if they are long integers in python, to learn more about how it gets converted and how python is interpreted you can find it in the documentation here .","title":"Literal Values"},{"location":"conditionals/#inequalities","text":"To talk about inequalities, we must first need to talk about what an equality is. In python, equality is the symbol == and will directly check if one object is equal to another object. This is not the same as the 'is' keyword. Consider this code: example-8.py from 1 to 15 # example-8.py first example # Showing the difference between the is keyword and the equality operator list_1 = [ 10 ] list_2 = list_1 list_3 = list ( list_1 ) # test all of the equalities print ( list_1 == list_2 ) print ( list_1 == list_3 ) print ( list_2 == list_3 ) # test all of the is comparisons print ( list_1 is list_2 ) print ( list_1 is list_3 ) print ( list_2 is list_3 ) Output True True True True False False Here you can see that the difference between the equality operator and the is statement quite apparent. The equality operator looks to see if the values inside the lists are the same, whereas the is operator looks to see if the labels point to the same object. Understanding this key difference will help you to write good evaluation statements that behave the way you intend them to. Inequalities cover the other types of comparisons you might want to accomplish, consider this table: Symbol Meaning == equal to != not equal to > greater than >= greater than or equal to < less than <= less than or equal to A comparison always evaluates from left to right in the sense that if you were to create a comparison such as: print ( variable_1 > variable_2 ) it would compare if variable_1 is greater than variable_2. This can be complicated by multiple evaluations however, consider this example: print ( variable_1 > variable_2 > variable_3 ) Python handles this type of evaluation by taking the first two and then the last two variables and evaluating them separately. This makes it equivalent to; print ( variable_1 > variable_2 and variable_2 > variable_3 ) Make sure you consider this behaviour when you write your own conditional statements.","title":"Inequalities"},{"location":"conditionals/#if","text":"The first control statement you need to learn in Python is the if statement. If statements are used in the construction of conditional execution to create decision making code. The 'if' part will execute if the statement evaluates as true. Consider this example: example-3.py from 1 to 30 # example-3.py # if statements and control statements # Remember an if statement only triggers if it evaluates to True variable_1 = 10 variable_2 = 5 variable_3 = \"trigonometry\" variable_4 = 5.5 variable_5 = False if variable_1 > variable_2 : print ( f \" { variable_1 } is greater than { variable_2 } \" ) if variable_1 < variable_2 : print ( f \" { variable_1 } is less than { variable_2 } \" ) if variable_1 == variable_2 : print ( f \"variable_1: { variable_1 } and variable_2: { variable_2 } are equal\" ) if type ( variable_3 ) == int : print ( f \"variable_3 is an integer not a string, see: { variable_3 } \" ) if type ( variable_4 ) == float : print ( f \"variable_4 is a float type with a value of { variable_4 } \" ) if variable_5 is True : print ( f \"variable_5 is { variable_5 } \" ) if variable_5 is not True : print ( f \"variable_5 is { variable_5 } \" ) Output 10 is greater than 5 variable_4 is a float type with a value of 5.5 variable_5 is False Looking through this code you can see that some of the statements aren't printed. For instance, variable_3 is not of a type integer, you can also see that there are some statements that are there to catch different values of variable_1 and variable_2, and a statement to catch if variable_5 is True or False. This way of writing code isn't very readable however, because there are no logical connections between one statement and the others. This is where the elif statement comes in.","title":"If"},{"location":"conditionals/#elif","text":"We use the 'else if' or 'elif' statement to logically join statements together and run multiple checks on the same objects. If we take the code above and turn it into a more complex set of if statements then we get something a little clearer: example-4.py from 1 to 30 # example-4.py # elif statements and evaluations # Remember an if or elif statement only triggers if it evaluates to True variable_1 = 10 variable_2 = 5 variable_3 = \"trigonometry\" variable_4 = 5.5 variable_5 = False if variable_1 > variable_2 : print ( f \" { variable_1 } is greater than { variable_2 } \" ) elif variable_1 < variable_2 : print ( f \" { variable_1 } is less than { variable_2 } \" ) elif variable_1 == variable_2 : print ( f \"variable_1: { variable_1 } and variable_2: { variable_2 } are equal\" ) if type ( variable_3 ) == int : print ( f \"variable_3 is an integer not a string, see: { variable_3 } \" ) if type ( variable_4 ) == float : print ( f \"variable_4 is a float type with a value of { variable_4 } \" ) if variable_5 is True : print ( f \"variable_5 is { variable_5 } \" ) elif variable_5 is not True : print ( f \"variable_5 is { variable_5 } \" ) Output 10 is greater than 5 variable_4 is a float type with a value of 5.5 variable_5 is False As you can see the code is a little more logically grouped and it helps with processing cycles too. Once an if statement is executed, if it evaluates to true in the first part of the statement then it doesn't have to run any of the elif statements. As soon as one of the steps evaluates to true then the evaluation can exit there. In our previous example, each if statement has to be evaluated independently, increasing the amount of processing that needs to be done and making your code less readable. But what happens if you evaluate something and you don't trigger any condition, well there is the 'else' statement that handles that.","title":"Elif"},{"location":"conditionals/#else","text":"The else statement is designed to run after everything in the if/elif statement evaluates to False. Consider it a piece of code that runs 'if all else fails'. Else statements can also be used in loops which you will see later. Let's take the code we had in example 3 and 4 and improve it further to incorporate else statements: example-5.py from 1 to 40 # example-5.py # else statements # Remember an if or elif statement only triggers if it evaluates to True, # if all of them evaluate to false then the else statement runs. variable_1 = 10 variable_2 = 5 variable_3 = \"trigonometry\" variable_4 = 5.5 variable_5 = False if variable_1 > variable_2 : print ( f \" { variable_1 } is greater than { variable_2 } \" ) elif variable_1 < variable_2 : print ( f \" { variable_1 } is less than { variable_2 } \" ) elif variable_1 == variable_2 : print ( f \"variable_1: { variable_1 } and variable_2: { variable_2 } are equal\" ) else : print ( f \"Something went very wrong!! Variable 1 or 2 are broken.\" ) if type ( variable_3 ) == int : print ( f \"variable_3 is an integer not a string, see: { variable_3 } \" ) else : print ( f \"variable_3 is not an integer, see: { variable_3 } \" ) if type ( variable_4 ) == float : print ( f \"variable_4 is a float type with a value of { variable_4 } \" ) else : print ( f \"variable_4 is the wrong type.\" ) if variable_5 is True : print ( f \"variable_5 is { variable_5 } \" ) elif variable_5 is not True : print ( f \"variable_5 is { variable_5 } \" ) else : print ( f \"variable_5 is not a Boolean for some reason.\" ) ## This file has some dependencies in the README.md file, check line 50. If you change this file you might have to change it there too. Output 10 is greater than 5 variable_3 is not an integer, see: trigonometry variable_4 is a float type with a value of 5.5 variable_5 is False","title":"Else"},{"location":"conditionals/#boolean-logic","text":"All logic inside a computer boils down to True or False logic. True is either represented by its name or by the number 1, False is represented by its name or 0. All modern classical (Von Neumann architecture) computers are based off of Boolean logic and Boolean algebra, this means that all the components inside the machine have been developed to take 1's and 0's and represent them in every way we need to create useful data with. For the purposes of programming however, you need to understand how truth tables refer to AND, OR, NAND (not AND) and NOR (not OR) logic. Here are the truth tables for each of the logical comparisons AND True False True True False False False False OR True False True True True False True False NAND True False True False True False True True NOR True False True False False False False True When considering your if statements, you need to consider how they will be evaluated. Consider this code fragment: example-5.py from 1 to 40 # example-5.py # else statements # Remember an if or elif statement only triggers if it evaluates to True, # if all of them evaluate to false then the else statement runs. variable_1 = 10 variable_2 = 5 variable_3 = \"trigonometry\" variable_4 = 5.5 variable_5 = False if variable_1 > variable_2 : print ( f \" { variable_1 } is greater than { variable_2 } \" ) elif variable_1 < variable_2 : print ( f \" { variable_1 } is less than { variable_2 } \" ) elif variable_1 == variable_2 : print ( f \"variable_1: { variable_1 } and variable_2: { variable_2 } are equal\" ) else : print ( f \"Something went very wrong!! Variable 1 or 2 are broken.\" ) if type ( variable_3 ) == int : print ( f \"variable_3 is an integer not a string, see: { variable_3 } \" ) else : print ( f \"variable_3 is not an integer, see: { variable_3 } \" ) if type ( variable_4 ) == float : print ( f \"variable_4 is a float type with a value of { variable_4 } \" ) else : print ( f \"variable_4 is the wrong type.\" ) if variable_5 is True : print ( f \"variable_5 is { variable_5 } \" ) elif variable_5 is not True : print ( f \"variable_5 is { variable_5 } \" ) else : print ( f \"variable_5 is not a Boolean for some reason.\" ) ## This file has some dependencies in the README.md file, check line 50. If you change this file you might have to change it there too. Output 10 is greater than 5 variable_3 is not an integer, see: trigonometry variable_4 is a float type with a value of 5.5 variable_5 is False","title":"Boolean Logic"},{"location":"functions/intro-to-functions/","text":"Functions","title":"Introduction to functions"},{"location":"functions/intro-to-functions/#functions","text":"","title":"Functions"},{"location":"functions/built-in-functions/","text":"","title":"Built-in functions"},{"location":"functions/user-functions/","text":"Functions Functions are self contained objects that are used to create code that we often want to reuse. The most arbitrary use of a function is in this code: example-1.py from 1 to 10 # example-1.py first example # Precedence of or & and meal = \"Spaghetti Carbonara\" money = 0 if meal == \"Spaghetti Carbonara\" or meal == \"Lasagne\" and money >= 2 : print ( \"Dinner is served!!\" ) else : print ( \"Can't deliver dinner :( \" ) Output Dinner is served!! As you can see, we have created our first function. To create a function you must first use the def keyword followed by the name for the function. The naming conventions for functions are the same as they are for variables. However, it is good practice to have descriptive names for your functions so that you can recognise what they do at a glance.","title":"User created functions"},{"location":"functions/user-functions/#functions","text":"Functions are self contained objects that are used to create code that we often want to reuse. The most arbitrary use of a function is in this code: example-1.py from 1 to 10 # example-1.py first example # Precedence of or & and meal = \"Spaghetti Carbonara\" money = 0 if meal == \"Spaghetti Carbonara\" or meal == \"Lasagne\" and money >= 2 : print ( \"Dinner is served!!\" ) else : print ( \"Can't deliver dinner :( \" ) Output Dinner is served!! As you can see, we have created our first function. To create a function you must first use the def keyword followed by the name for the function. The naming conventions for functions are the same as they are for variables. However, it is good practice to have descriptive names for your functions so that you can recognise what they do at a glance.","title":"Functions"},{"location":"values-and-types/","text":"Values and Types Explain what types are first, then move on to how many and such. There are 4 basic types in python; Boolean, integer, floating point number and string. Booleans or \"bools\" are either true or false, a one or a zero, they are representative of the binary calculations that make computers work. Integers are any whole number and can be both positive and negative numbers, where as floating point numbers are anything with a decimal point in. A string is an interesting type as it also works like an iterable which we'll see more of later, but it stores a string of characters together. Every time we make a value that a computer needs to be able to reuse, we call that type a \"variable\". Let's look at some examples of how we use types and make variables: Basic Types: Creating your first variable To create your first variable it's pretty easy, you just name it and then use the assignment operator to assign it to that name. This will create a sort of pet name, pseudonym, or alias for a location in memory where the object that contains the value is then stored. Anytime you use that pseudonym it'll refer to whatever is stored in that object again. It's easier to show you then it is to explain it. In the next few examples you'll see how to create and label a variable in python. The two things you need to keep in mind when creating a variable are; an appropriate name/label, and the type of variable you need to create. Warning Variables are the fundamentals of programming and are included everywhere, so make sure you feel comfortable with everything here before you move on to other sections. Naming Conventions Variable names can start with a number, letter, or underscore, but not any other special character. PEP8 Python programming conventions say that variables should be named with all lower case letters, for longer variable names each word should be separated by underscores: example-1.py from the beginning to the end # example-1.py # a simple variable followed by the equals sign, we can make it any type of variable but we will make it an integer variable = 10 # This is the same thing but with a more descriptive and longer variable name the_number_of_vowels_in_banana = 3 #blank line print ( variable ) print ( the_number_of_vowels_in_banana ) Check As code is read many more times than its written, generally speaking, it is better to have longer variable names to help others understand your code better. It's also good practice when you start to be very descriptive, so when you look back over your code to prompt you and study your programming, you'll remember what it was you were doing and how it works at a glance. Both of the names in the above example are kind of bad, one is too short and the other too long, try to strike a balance between the two for maximum understanding while preventing you from having to type out crazy long names for variables every time you want to use them. Assignment Python is a dynamically typed language, what this means is that you don't have to know what type of data you want to label with a variable name to be able to create it. In statically typed languages such as the 'C' family of languages, you must declare the type of data you are going to store in memory before you store it. In python, variables dynamically change behind the scenes to accommodate different basic types, here's an example: example-2.py from the beginning to the end # example-2.py variable = 10 print ( variable ) variable = True print ( variable ) variable = \"hello\" print ( variable ) variable = 3.14 print ( variable ) In this example, our variable ambiguously called \"variable\" is a single label pointing to a location in memory. Each time we use the assignment operator (the equals sign), we force the variable to reference a different location in memory that stores a different type of data, and then ask it to print out to the screen. We're printing out the contents of the same alias every time, we're just the memory location. We can also check the types of data with the next example: example-3.py from the beginning to the end # example-3.py variable = 10 print ( variable ) print ( type ( variable )) variable = True print ( variable ) print ( type ( variable )) variable = \"hello\" print ( variable ) print ( type ( variable )) variable = 3.14 print ( variable ) print ( type ( variable )) Output 10 <class 'int'> True <class 'bool'> hello <class 'str'> 3.14 <class 'float'> This does exactly the same as example 2 but it also prints out the basic type or object of the variable at each stage. Now you can see each of the types printed out too... see for yourself! Test Your Knowledge: Making your own variables For this knowledge test, using appropriate naming conventions try making your own variables to describe numbers and strings you might use in your own programs. Make variables to contain a happy birthday wish, the value of pi to 5 decimal places, your favourite integer under 100, a variable containing the meaning of life, and the true or false logic of whether a mouse is larger than a Giraffe. Try to make at least one variable of every basic type. Composite Types Lists There are also types that store or arrange basic types to make it easier to work with them, the three composite types are; lists, dictionaries, and tuples. Lists store a malleable group of variables that are easy to work with because the values can be referred to by index. An index is the numerical location of the position that a variable is in a list. Consider this list: example-4.py from 1 to 3 # example-4.py name_of_a_list = [ \"variables\" , \"are\" , \"contained\" , \"in\" , \"here\" , 12 , True , 33.33334 ] As all indexes start at the number zero as a general rule in programming, we could also represent this data in a table like this: index number 0 1 2 3 4 5 6 7 variable data \"variables\" \"are\" \"contained\" \"in\" \"here\" 12 True 33.33334 We can write code to interact with an index value like this: example-4.py from 1 to 5 # example-4.py name_of_a_list = [ \"variables\" , \"are\" , \"contained\" , \"in\" , \"here\" , 12 , True , 33.33334 ] print ( name_of_a_list [ 3 ]) Question Which one of the variables in the above example do you think gets printed?? If you guessed \"contained\" then you just got caught out by the one thing that catches out every programmer at least once. As we said, all indexes start at the number 0 as a general rule. So \"variables\" is at index 0, \"are\" at index 1, and so on. The astute among you may have noticed that the only difference between interacting with a list and making a list is the use of the assignment operator. That's true of all variables, assigning requires the assignment operator and using the label of the data doesn't. Tuples are similar to lists in that they have an index number for the location of the data, but they are not mutable, which is to say they cannot change their data once they are created. Tuples Tuples can be treated in two ways, as a record and as an immutable list. As a record, tuples are used to store data in a certain order and keep it that way, generally for use later in the code: example-5.py from 1 to 10 # example-5.py first example # showing that tuples are immutable by breaking things # odds of being struck by lightning tuple_as_a_record = ( \"lightning strike\" , ( 1 , 700000 )) accident , ( number_of_people , in_population ) = tuple_as_a_record # tuple unpacking print ( f \"\"\"The chance of being the victim of a { accident } , is { number_of_people } in { in_population } \"\"\" ) In this example, the data is stored in a tuple and then unpacked for use in the print statement. You could print a packed tuple but you would get a print out with brackets too. Unpacking a tuple creates new objects that are referenced by the variables used in the unpacking, if you change the value of those variables then you'll only change the value of the new objects and not the values in the tuple you just unpacked. This is a good way to have records hard coded into a program Here is a short example of how that works: Tuple unpacking doesn't work properly, look over this again and fix this example and explanation to be clearer example-5.py from 12 to the end # example-5.py second example # showing that tuples are immutable by breaking things tuple_as_a_record = ( \"meteor shower\" , ( 1 , 20000 )) accident , ( number_of_people , in_population ) = tuple_as_a_record # tuple unpacking accident = \"shark attack\" print ( accident ) print ( tuple_as_a_record ) Output shark attack ('meteor shower', (1, 20000)) This brings us nicely onto the other way to use tuples, as immutable lists. The reason you use tuples as immutable lists is so that you can use slicing and other list functionality that also works with tuples, but without the fear of someone else in your production team modifying the list by accident. Another way to store data as records is to store it as a dictionary. Dictionary Dictionaries are an interesting data structure, its used to store data in key value pairs so that you can easily access the data by label instead of by index value. This is especially helpful if you want to dynamically create a csv file or know you need to store categorised data throughout a program, but other people are in charge of much of the data input. Dictionaries always have this form: d = { < key > : < value > , < key > : < value > , . . . < key > : < value > } Multiple values can be stored under the same key, and even any other objects, and all of them can be referenced with the key. Consider this assignment: example-6.py from 1 to 21 # example-6.py first example # how to create a dictionary and how to fill it our_dict = { \"Boston\" : \"Bruins\" , \"Buffalo\" : \"Sabres\" , \"Detroit\" : \"Redwings\" , \"Florida\" : \"Panthers\" , \"Montreal\" : \"Canadiens\" , \"Ottawa\" : \"Senators\" , \"Tampa\" : \"Lightning\" , \"Toronto\" : \"Maple Leafs\" } print ( type ( our_dict )) our_dict [ \"New Jersey\" ] = \"Devils\" print ( our_dict ) print ( our_dict . items ()) ## prints out all the pairs of <keys>:<values> print ( our_dict . keys ()) ## prints out all the <keys> print ( our_dict . values ()) ## prints out all the <values> Output <class 'dict'> {'Boston': 'Bruins', 'Buffalo': 'Sabres', 'Detroit': 'Redwings', 'Florida': 'Panthers', 'Montreal': 'Canadiens', 'Ottawa': 'Senators', 'Tampa': 'Lightning', 'Toronto': 'Maple Leafs', 'New Jersey': 'Devils'} dict_items([('Boston', 'Bruins'), ('Buffalo', 'Sabres'), ('Detroit', 'Redwings'), ('Florida', 'Panthers'), ('Montreal', 'Canadiens'), ('Ottawa', 'Senators'), ('Tampa', 'Lightning'), ('Toronto', 'Maple Leafs'), ('New Jersey', 'Devils')]) dict_keys(['Boston', 'Buffalo', 'Detroit', 'Florida', 'Montreal', 'Ottawa', 'Tampa', 'Toronto', 'New Jersey']) dict_values(['Bruins', 'Sabres', 'Redwings', 'Panthers', 'Canadiens', 'Senators', 'Lightning', 'Maple Leafs', 'Devils']) In this example we can see that it is reasonably simple to create a dictionary, you can either create an empty one or in our example have it pre-filled with a few things to get the ball rolling. Then as you progress in the program you can also add to it like any other dynamic object, this is done in our code with the line: example-6.py from 15 to 15 our_dict [ \"New Jersey\" ] = \"Devils\" The first part is the name of our dictionary, then the key we want to use inside the square brackets, and then the assignment operator followed by the value we want to give it.Using all of these basic and composite types are what make up everything you'll do to store, label, and create data inside a python program. Test Your Knowledge: Make for yourself a list, a tuple and a dictionary. Then look at different ways to add, remove, delete and generally manipulate the data that is associated with these composite types. The file \"test-your-knowledge.py\" has some broken code for you to fix and some notes on interesting ways to manipulate data in these composite types for you to complete.","title":"Values and Types"},{"location":"values-and-types/#values-and-types","text":"Explain what types are first, then move on to how many and such. There are 4 basic types in python; Boolean, integer, floating point number and string. Booleans or \"bools\" are either true or false, a one or a zero, they are representative of the binary calculations that make computers work. Integers are any whole number and can be both positive and negative numbers, where as floating point numbers are anything with a decimal point in. A string is an interesting type as it also works like an iterable which we'll see more of later, but it stores a string of characters together. Every time we make a value that a computer needs to be able to reuse, we call that type a \"variable\". Let's look at some examples of how we use types and make variables:","title":"Values and Types"},{"location":"values-and-types/#basic-types-creating-your-first-variable","text":"To create your first variable it's pretty easy, you just name it and then use the assignment operator to assign it to that name. This will create a sort of pet name, pseudonym, or alias for a location in memory where the object that contains the value is then stored. Anytime you use that pseudonym it'll refer to whatever is stored in that object again. It's easier to show you then it is to explain it. In the next few examples you'll see how to create and label a variable in python. The two things you need to keep in mind when creating a variable are; an appropriate name/label, and the type of variable you need to create. Warning Variables are the fundamentals of programming and are included everywhere, so make sure you feel comfortable with everything here before you move on to other sections.","title":"Basic Types: Creating your first variable"},{"location":"values-and-types/#naming-conventions","text":"Variable names can start with a number, letter, or underscore, but not any other special character. PEP8 Python programming conventions say that variables should be named with all lower case letters, for longer variable names each word should be separated by underscores: example-1.py from the beginning to the end # example-1.py # a simple variable followed by the equals sign, we can make it any type of variable but we will make it an integer variable = 10 # This is the same thing but with a more descriptive and longer variable name the_number_of_vowels_in_banana = 3 #blank line print ( variable ) print ( the_number_of_vowels_in_banana ) Check As code is read many more times than its written, generally speaking, it is better to have longer variable names to help others understand your code better. It's also good practice when you start to be very descriptive, so when you look back over your code to prompt you and study your programming, you'll remember what it was you were doing and how it works at a glance. Both of the names in the above example are kind of bad, one is too short and the other too long, try to strike a balance between the two for maximum understanding while preventing you from having to type out crazy long names for variables every time you want to use them.","title":"Naming Conventions"},{"location":"values-and-types/#assignment","text":"Python is a dynamically typed language, what this means is that you don't have to know what type of data you want to label with a variable name to be able to create it. In statically typed languages such as the 'C' family of languages, you must declare the type of data you are going to store in memory before you store it. In python, variables dynamically change behind the scenes to accommodate different basic types, here's an example: example-2.py from the beginning to the end # example-2.py variable = 10 print ( variable ) variable = True print ( variable ) variable = \"hello\" print ( variable ) variable = 3.14 print ( variable ) In this example, our variable ambiguously called \"variable\" is a single label pointing to a location in memory. Each time we use the assignment operator (the equals sign), we force the variable to reference a different location in memory that stores a different type of data, and then ask it to print out to the screen. We're printing out the contents of the same alias every time, we're just the memory location. We can also check the types of data with the next example: example-3.py from the beginning to the end # example-3.py variable = 10 print ( variable ) print ( type ( variable )) variable = True print ( variable ) print ( type ( variable )) variable = \"hello\" print ( variable ) print ( type ( variable )) variable = 3.14 print ( variable ) print ( type ( variable )) Output 10 <class 'int'> True <class 'bool'> hello <class 'str'> 3.14 <class 'float'> This does exactly the same as example 2 but it also prints out the basic type or object of the variable at each stage. Now you can see each of the types printed out too... see for yourself! Test Your Knowledge: Making your own variables For this knowledge test, using appropriate naming conventions try making your own variables to describe numbers and strings you might use in your own programs. Make variables to contain a happy birthday wish, the value of pi to 5 decimal places, your favourite integer under 100, a variable containing the meaning of life, and the true or false logic of whether a mouse is larger than a Giraffe. Try to make at least one variable of every basic type.","title":"Assignment"},{"location":"values-and-types/#composite-types","text":"","title":"Composite Types"},{"location":"values-and-types/#lists","text":"There are also types that store or arrange basic types to make it easier to work with them, the three composite types are; lists, dictionaries, and tuples. Lists store a malleable group of variables that are easy to work with because the values can be referred to by index. An index is the numerical location of the position that a variable is in a list. Consider this list: example-4.py from 1 to 3 # example-4.py name_of_a_list = [ \"variables\" , \"are\" , \"contained\" , \"in\" , \"here\" , 12 , True , 33.33334 ] As all indexes start at the number zero as a general rule in programming, we could also represent this data in a table like this: index number 0 1 2 3 4 5 6 7 variable data \"variables\" \"are\" \"contained\" \"in\" \"here\" 12 True 33.33334 We can write code to interact with an index value like this: example-4.py from 1 to 5 # example-4.py name_of_a_list = [ \"variables\" , \"are\" , \"contained\" , \"in\" , \"here\" , 12 , True , 33.33334 ] print ( name_of_a_list [ 3 ]) Question Which one of the variables in the above example do you think gets printed?? If you guessed \"contained\" then you just got caught out by the one thing that catches out every programmer at least once. As we said, all indexes start at the number 0 as a general rule. So \"variables\" is at index 0, \"are\" at index 1, and so on. The astute among you may have noticed that the only difference between interacting with a list and making a list is the use of the assignment operator. That's true of all variables, assigning requires the assignment operator and using the label of the data doesn't. Tuples are similar to lists in that they have an index number for the location of the data, but they are not mutable, which is to say they cannot change their data once they are created.","title":"Lists"},{"location":"values-and-types/#tuples","text":"Tuples can be treated in two ways, as a record and as an immutable list. As a record, tuples are used to store data in a certain order and keep it that way, generally for use later in the code: example-5.py from 1 to 10 # example-5.py first example # showing that tuples are immutable by breaking things # odds of being struck by lightning tuple_as_a_record = ( \"lightning strike\" , ( 1 , 700000 )) accident , ( number_of_people , in_population ) = tuple_as_a_record # tuple unpacking print ( f \"\"\"The chance of being the victim of a { accident } , is { number_of_people } in { in_population } \"\"\" ) In this example, the data is stored in a tuple and then unpacked for use in the print statement. You could print a packed tuple but you would get a print out with brackets too. Unpacking a tuple creates new objects that are referenced by the variables used in the unpacking, if you change the value of those variables then you'll only change the value of the new objects and not the values in the tuple you just unpacked. This is a good way to have records hard coded into a program Here is a short example of how that works: Tuple unpacking doesn't work properly, look over this again and fix this example and explanation to be clearer example-5.py from 12 to the end # example-5.py second example # showing that tuples are immutable by breaking things tuple_as_a_record = ( \"meteor shower\" , ( 1 , 20000 )) accident , ( number_of_people , in_population ) = tuple_as_a_record # tuple unpacking accident = \"shark attack\" print ( accident ) print ( tuple_as_a_record ) Output shark attack ('meteor shower', (1, 20000)) This brings us nicely onto the other way to use tuples, as immutable lists. The reason you use tuples as immutable lists is so that you can use slicing and other list functionality that also works with tuples, but without the fear of someone else in your production team modifying the list by accident. Another way to store data as records is to store it as a dictionary.","title":"Tuples"},{"location":"values-and-types/#dictionary","text":"Dictionaries are an interesting data structure, its used to store data in key value pairs so that you can easily access the data by label instead of by index value. This is especially helpful if you want to dynamically create a csv file or know you need to store categorised data throughout a program, but other people are in charge of much of the data input. Dictionaries always have this form: d = { < key > : < value > , < key > : < value > , . . . < key > : < value > } Multiple values can be stored under the same key, and even any other objects, and all of them can be referenced with the key. Consider this assignment: example-6.py from 1 to 21 # example-6.py first example # how to create a dictionary and how to fill it our_dict = { \"Boston\" : \"Bruins\" , \"Buffalo\" : \"Sabres\" , \"Detroit\" : \"Redwings\" , \"Florida\" : \"Panthers\" , \"Montreal\" : \"Canadiens\" , \"Ottawa\" : \"Senators\" , \"Tampa\" : \"Lightning\" , \"Toronto\" : \"Maple Leafs\" } print ( type ( our_dict )) our_dict [ \"New Jersey\" ] = \"Devils\" print ( our_dict ) print ( our_dict . items ()) ## prints out all the pairs of <keys>:<values> print ( our_dict . keys ()) ## prints out all the <keys> print ( our_dict . values ()) ## prints out all the <values> Output <class 'dict'> {'Boston': 'Bruins', 'Buffalo': 'Sabres', 'Detroit': 'Redwings', 'Florida': 'Panthers', 'Montreal': 'Canadiens', 'Ottawa': 'Senators', 'Tampa': 'Lightning', 'Toronto': 'Maple Leafs', 'New Jersey': 'Devils'} dict_items([('Boston', 'Bruins'), ('Buffalo', 'Sabres'), ('Detroit', 'Redwings'), ('Florida', 'Panthers'), ('Montreal', 'Canadiens'), ('Ottawa', 'Senators'), ('Tampa', 'Lightning'), ('Toronto', 'Maple Leafs'), ('New Jersey', 'Devils')]) dict_keys(['Boston', 'Buffalo', 'Detroit', 'Florida', 'Montreal', 'Ottawa', 'Tampa', 'Toronto', 'New Jersey']) dict_values(['Bruins', 'Sabres', 'Redwings', 'Panthers', 'Canadiens', 'Senators', 'Lightning', 'Maple Leafs', 'Devils']) In this example we can see that it is reasonably simple to create a dictionary, you can either create an empty one or in our example have it pre-filled with a few things to get the ball rolling. Then as you progress in the program you can also add to it like any other dynamic object, this is done in our code with the line: example-6.py from 15 to 15 our_dict [ \"New Jersey\" ] = \"Devils\" The first part is the name of our dictionary, then the key we want to use inside the square brackets, and then the assignment operator followed by the value we want to give it.Using all of these basic and composite types are what make up everything you'll do to store, label, and create data inside a python program.","title":"Dictionary"},{"location":"values-and-types/#test-your-knowledge","text":"Make for yourself a list, a tuple and a dictionary. Then look at different ways to add, remove, delete and generally manipulate the data that is associated with these composite types. The file \"test-your-knowledge.py\" has some broken code for you to fix and some notes on interesting ways to manipulate data in these composite types for you to complete.","title":"Test Your Knowledge:"}]}